# æ ‘

**æ­¤ç¬”è®°ç”±AXuanCreatoråˆ¶ä½œ,éƒ¨åˆ†èµ„æ–™æ¥æºäºç½‘ç»œ,GITHUBåœ°å€:[AXuanCreator/NOTE-Data-Structure-and-Algorithms: æ•°æ®ç»“æ„ä¸ç®—æ³•çš„ä¸€äº›ç¬”è®°ï¼Œç›®å‰åŸºäºC++ (github.com)](https://github.com/AXuanCreator/NOTE-Data-Structure-and-Algorithms)**



#### äºŒå‰æ ‘çš„å‰åºéå†
![432331219256822](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage432331219256822.png)
##### çŸ¥è¯†ç‚¹

>å‰åºéå†

* å‰åºéå†é¦–å…ˆè®¿é—® **æ ¹èŠ‚ç‚¹** ï¼Œç„¶åéå† **å·¦å­æ ‘** ï¼Œæœ€åéå† **å³å­æ ‘** ã€‚
<img src="D:\Files_Work\Vnote\CandCPP\æ•°æ®ç»“æ„ä¸ç®—æ³•\vx_images\555223319249491.gif" alt="555223319249491" style="zoom:50%;" />

##### é€’å½’
```cpp
    /**
     * Definition for a binary tree node.
     * struct TreeNode {
     *     int val;
     *     TreeNode *left;
     *     TreeNode *right;
     *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
     *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
     *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
     * };
     */
    class Solution
    {
    public:
        void treeNodePush(TreeNode *ptr, vector<int> &ans)
        {
            if (ptr == nullptr)
                return;

            ans.push_back(ptr->val);       // å°†å½“å‰èŠ‚ç‚¹å€¼æ’å…¥
            treeNodePush(ptr->left, ans);  // ä¼ é€’å·¦åˆ†æ”¯ï¼Œè‹¥å­˜åœ¨ï¼Œåˆ™æ’å…¥å€¼
            treeNodePush(ptr->right, ans); // ä¼ é€’å³åˆ†æ”¯

            return; // å¯ä¸å†™ï¼Œä»…ä¸ºç†è§£
        }
        vector<int> preorderTraversal(TreeNode *root)
        {
            vector<int> ans;
            treeNodePush(root, ans);

            return ans;
        }
    };
```
>è§£æ

* ä½•ä¸ºå‰åºéå†ï¼Ÿå‰åºéå†æŒ‡å°† **æ ¹èŠ‚ç‚¹** æ”¾åœ¨é¦–ä½ï¼Œç„¶åéå†å·¦ã€å³å­æ ‘ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œé™¤äº†æ ¹èŠ‚ç‚¹å¤–ï¼Œå·¦æ ‘æ”¯ç‚¹ä¸º **æ¬¡ä¼˜å…ˆ** çº§åˆ«ï¼Œé‚£ä¹ˆæ€è·¯å°±å¾ˆæ¸…æ™°äº†ï¼š
    * ä¼˜å…ˆéå† **å·¦æ”¯ç‚¹** ï¼Œ å› ä¸ºå·¦æ”¯ç‚¹åŒæ—¶ä¹Ÿæ˜¯æ ¹èŠ‚ç‚¹(é™¤æœ€åä¸€ä¸ªå·¦æ”¯ç‚¹å¤–)
    * åœ¨éå†å®Œå·¦æ”¯ç‚¹å`(node==nullptr)`ï¼Œé€’å½’å¼€å§‹è¿”å›çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹å¹¶ **ä¼ é€’å³æ”¯ç‚¹** ã€‚ 
    * è‹¥å¯¹äºä¼ é€’çš„æ”¯ç‚¹ä¾ç„¶å­˜åœ¨ **å·¦æ”¯ç‚¹** ï¼Œé‚£ä¹ˆä¼šä¼˜å…ˆéå†å·¦æ”¯ç‚¹ï¼Œç›´è‡³å·¦æ”¯ç‚¹ä¸º **ç©º** ï¼Œ ç„¶åè°ƒç”¨ä¸‹ä¸€ä¸ªå‡½æ•°`treeNodePush(ptr->right, ans)`


##### è¿­ä»£
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution
{
public:
    vector<int> preorderTraversal(TreeNode *root)
    {
        vector<int> res;
        
       	// æ£€æµ‹æ˜¯å¦ä¸ºç©ºèŠ‚ç‚¹
        if (root == nullptr)
        {
            return res;
        }

        
        stack<TreeNode *> stk;	// è®¾ç«‹æ ˆï¼Œå…ˆå…¥åå‡º
        TreeNode *node = root;  // ç›¸å½“äºç§»åŠ¨èŠ‚ç‚¹
        
        while (!stk.empty() || node != nullptr) // å½“æ ˆä¸ä¸ºç©ºæˆ–è€…nodeä¸æŒ‡å‘nullptr
        {
            while (node != nullptr) // å…ˆéå†å·¦å­æ ‘ï¼Œåœ¨éå†çš„è¿‡ç¨‹ä¸­è½½å…¥èŠ‚ç‚¹åˆ°æ ˆå’Œå®¹å™¨ä¸­
            {
                res.emplace_back(node->val);	// å…ˆå°†èŠ‚ç‚¹å€¼è®°å½•åˆ°resä¸­
                stk.emplace(node);	// æ¨å…¥
                node = node->left;	// å‘å·¦èŠ‚ç‚¹å‰è¿›
            }
			
            // æ­¤æ—¶å½“å‰èŠ‚ç‚¹nodeä¸ºç©ºèŠ‚ç‚¹
            node = stk.top(); 	// å½“å·¦å­æ ‘æ²¡æœ‰å…ƒç´ ï¼Œä»æ ˆé¡¶(ä¹Ÿå°±æ˜¯ä¸Šä¸€ä¸ªèŠ‚ç‚¹)èµ‹å€¼ç»™node
            stk.pop();  	// æ ˆé¡¶å¼¹å‡º
            node = node->right; 	// æŒ‡å‘å³è¾¹
        }
        return res;
    }
};

```

>è§£æ

* è¿­ä»£å’Œé€’å½’å…¶å®å¾ˆç›¸ä¼¼ï¼Œé€’å½’éšè—äº†æ ˆå…¥æ ˆå‡ºçš„ï¼Œè€Œè¿­ä»£åˆ™æ˜¾å¼äº†æ ˆå…¥æ ˆå‡º
* æ€è·¯ï¼š
    * è¿›å…¥ **å¤–å¾ªç¯** çš„æ¡ä»¶æ˜¯ `!stk.empty() || node != nullptr`ï¼Œå³å½“`stk`ä¸ä¸ºç©ºæˆ–è€…`node`æŒ‡å‘éç©ºèŠ‚ç‚¹
    * è¿›å…¥å¤–å¾ªç¯åï¼Œä¼šå†æ¬¡è¿›å…¥ **å†…å¾ªç¯**,è¿™ä¸ªå†…å¾ªç¯çš„ä½œç”¨æ˜¯éå† **å·¦æ”¯ç‚¹** å¹¶å°†èŠ‚ç‚¹æŒ‡é’ˆ **å‹å…¥æ ˆ**ï¼Œå¹¶ä¸”ä¿å­˜å€¼
    * å½“å·¦æ”¯ç‚¹å·²ä¸º **ç©º** ï¼Œä¼šä» **æ ˆé¡¶** æ‹¿å‡ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿™ä¸ªèŠ‚ç‚¹æ˜¯ **ç©ºèŠ‚ç‚¹** çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¹¶ä»æ ˆé¡¶ **åˆ é™¤** è¿™ä¸ªèŠ‚ç‚¹æŒ‡é’ˆ(ä¸‹ä¸€æ¬¡æ— æ³•å†æ‹¿å‡ºè¿™ä¸€èŠ‚ç‚¹)ã€‚ç„¶åå°†èŠ‚ç‚¹æŒ‡é’ˆæŒ‡å‘ **å½“å‰ä»æ ˆé¡¶æ‹¿å‡ºçš„æ–°èŠ‚ç‚¹çš„å³æ”¯ç‚¹**
    * å†æ¬¡è¿›å…¥ **å†…å¾ªç¯** ï¼Œ  è®°å½•ï¼Œåå¤ä¸Šé¢çš„æ­¥éª¤
    
* æ³¨æ„ï¼š
    * èŠ‚ç‚¹æŒ‡é’ˆä¸€æ—¦ä»æ ˆé‡Œæ‹¿å‡º`stk.top()`ï¼Œå°±ä¼šè¢«åŒæ­¥åˆ é™¤`stk.pop(); `ï¼Œå†ä¹Ÿæ— æ³•å›åˆ°è¿™ä¸ªèŠ‚ç‚¹ã€‚è¿™æ˜¯ä¸€ä¸ªå…³é”®ï¼Œåœ¨å¾ªç¯æ ¹èŠ‚ç‚¹çš„å³æ”¯ç‚¹æ—¶ï¼Œä¸ºäº†é˜²æ­¢å†æ¬¡è¿”å›åˆ°æ ¹èŠ‚ç‚¹ï¼Œæ­¤æ—¶ä¼šç›´æ¥è¿”å›åˆ° **æ ¹èŠ‚ç‚¹çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹**
    
>`stack<>`çš„æ‹“å±•

* `stack<Type> name`è¡¨ç¤ºä¸€ä¸ªç”¨äºå­˜å‚¨æŒ‡å‘`Type`å¯¹è±¡çš„ **æ ˆ** ã€‚æ ˆæ˜¯ä¸€ç§ **åè¿›å…ˆå‡º**ï¼ˆLIFOï¼‰çš„æ•°æ®ç»“æ„ï¼Œåªå…è®¸åœ¨ **æ ˆé¡¶** æ’å…¥å’Œåˆ é™¤å…ƒç´ ã€‚
* æ ˆæä¾›ä»¥ä¸‹å‡ ç§åŸºæœ¬æ“ä½œï¼š
    * `push(x)`ï¼šå°†å…ƒç´ xå‹å…¥æ ˆé¡¶ã€‚
    * `pop()`ï¼šä»æ ˆé¡¶å¼¹å‡ºä¸€ä¸ªå…ƒç´ ã€‚
    * `top()`ï¼šè·å–å½“å‰æ ˆé¡¶å…ƒç´ çš„å€¼ã€‚
    * `empty()`ï¼šåˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºã€‚
    * è‡ªå·±æŸ¥æ–‡æ¡£å»ğŸ˜ğŸ˜

* æ ˆçš„ç›¸å…³çŸ¥è¯†ç‚¹ä½äº [é˜Ÿåˆ—&æ ˆ](é˜Ÿåˆ—&æ ˆ.md)

##### Morriséå†
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution
{
public:
    vector<int> preorderTraversal(TreeNode *root)
    {
        vector<int> ans;
        TreeNode *cur = root;
        while (cur != nullptr)
        {
            if (cur->left == nullptr)
            {
                // å¦‚æœå·¦å­æ ‘ä¸ºç©ºï¼Œåˆ™å°†å½“å‰èŠ‚ç‚¹çš„å€¼åŠ å…¥ç»“æœé›†ï¼Œå¹¶å°†å½“å‰èŠ‚ç‚¹æ›´æ–°ä¸ºå…¶å³å­èŠ‚ç‚¹
                ans.push_back(cur->val);
                cur = cur->right;  // å³å­æ ‘éå† / å›åˆ°ä¸Šä¸€ä¸ªå·¦å­æ ‘çš„èŠ‚ç‚¹
            }
            else
            {
                // å¦‚æœå·¦å­æ ‘éç©ºï¼Œåˆ™å¯»æ‰¾å‰é©±èŠ‚ç‚¹
                TreeNode *predecessor = cur->left;
                while (predecessor->right != nullptr && predecessor->right != cur) // æ‰¾åˆ°å³å­èŠ‚ç‚¹çš„å°½å¤´
                {
                    predecessor = predecessor->right;
                }
                if (predecessor->right == nullptr)
                {
                    // å¦‚æœæ‰¾åˆ°çš„å‰é©±èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹ä¸ºç©ºï¼Œå°†å…¶å³å­èŠ‚ç‚¹æŒ‡å‘å½“å‰èŠ‚ç‚¹ï¼Œç„¶åå°†å½“å‰èŠ‚ç‚¹æ›´æ–°ä¸ºå…¶å·¦å­èŠ‚ç‚¹
                    predecessor->right = cur;
                    ans.push_back(cur->val);
                    cur = cur->left;
                }
                else
                {
                    // å¦‚æœå‰é©±èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹ä¸ºå½“å‰èŠ‚ç‚¹ï¼Œè¯´æ˜å‰é©±èŠ‚ç‚¹å·²éå†å®Œï¼Œå°†å…¶å³å­èŠ‚ç‚¹é‡ç½®ä¸ºç©ºï¼Œç„¶åå°†å½“å‰èŠ‚ç‚¹æ›´æ–°ä¸ºå…¶å³å­èŠ‚ç‚¹
                    predecessor->right = nullptr;
                    cur = cur->right;
                }
            }
        }
        return ans;
    }
};
```

>è§£æï¼š

* å‰é©±èŠ‚ç‚¹`predecessor`çš„ä½œç”¨æ—¶è¿æ¥ **ç›¸å¯¹ä½ç½®ä¸Šä¸€ä¸ª** çš„æ ¹èŠ‚ç‚¹ï¼Œä»¥è®©`cur`è¿”å›



>å›¾è§£

<img src="D:\Files_Work\Vnote\CandCPP\æ•°æ®ç»“æ„ä¸ç®—æ³•\vx_images\301672311248790.gif" alt="301672311248790" style="zoom:50%;" />

![276211818230365](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage276211818230365.jpg)
#### äºŒå‰æ ‘çš„ä¸­åºéå†
![485101610248790](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage485101610248790.png)

##### çŸ¥è¯†ç‚¹
>ä¸­åºéå†

* éå†é¡ºåºï¼š
    * å·¦å­èŠ‚ç‚¹
    * æ ¹èŠ‚ç‚¹
    * å³å­èŠ‚ç‚¹
* è§£é¢˜æŠ€å·§ï¼šæ— 
  
##### é€’å½’
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:
    void recursionTree(TreeNode* node , vector<int>& ans)
    {
        if(node==nullptr)
            return;

        /*
        * å…ˆæŠµè¾¾ç›¸å¯¹æœ€åº•éƒ¨çš„å·¦èŠ‚ç‚¹
        * ç„¶åè®°å½•
        * æ¢ç´¢è¯¥èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨å³å­æ ‘
        */
        recursionTree(node->left,ans);
        ans.push_back(node->val);
        recursionTree(node->right,ans);
            
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        recursionTree(root,ans);
        return ans;
    }
};
```
>è§£æ

* å…ˆæŠµè¾¾å¹¶è®°å½• **ç›¸å¯¹ä½ç½®å°¾å·´** å·¦å­èŠ‚ç‚¹
    * æ£€æµ‹æ­¤å·¦å­æ”¯ç‚¹æ˜¯å¦ **å­˜åœ¨å³å­èŠ‚ç‚¹**
        * è‹¥å­˜åœ¨ï¼Œåˆ™è¿›å…¥ **å³å­èŠ‚ç‚¹** ï¼Œä¸éœ€è¦å…ˆè®°å½•ï¼Œå…ˆæ£€æµ‹æ˜¯å¦ä¸º **æ ¹èŠ‚ç‚¹** ã€‚è‹¥å­˜åœ¨ï¼Œåˆ™å…ˆéå†è‡³æ­¤èŠ‚ç‚¹çš„ **æœ€å·¦å­èŠ‚ç‚¹**ï¼Œå¼€å§‹ä»å°¾å·´åˆ°å¼€å§‹è®°å½•ï¼Œç„¶åè®°å½•æ ¹èŠ‚ç‚¹ï¼Œæœ€åå†æ¬¡æ£€æµ‹æ˜¯éƒ½æœ‰ **å³å­èŠ‚ç‚¹**
        * è‹¥ä¸å­˜åœ¨ï¼Œåˆ™è¿”å›ä¸Šä¸€ä¸ªèŠ‚ç‚¹ï¼Œè®°å½•ï¼Œç„¶åå†æ¬¡æ£€æµ‹æ­¤èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨ **å³å­èŠ‚ç‚¹**
* åå¤ä¸Šè¿°æ­¥éª¤

##### è¿­ä»£
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:    
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        if (root == nullptr)
        {
            return ans;
        }
        
        stack<TreeNode*> stk;
        TreeNode* node = root;
        
        while(!stk.empty() || node!=nullptr)
        {
            while(node!=nullptr) //æŠµè¾¾æœ€å·¦å­èŠ‚ç‚¹
            {
                stk.emplace(node);
                node=node->left;
            }
            node = stk.top();  	// è®°å½•æ ˆé¡¶
            stk.pop();  		// å¼¹å‡º
            ans.push_back(node->val); // è®°å½•
            node=node->right; //å³ç§»åŠ¨
        }

        return ans;
    }
};
```
>è§£æ

<img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage399711111236657.png" alt="399711111236657" style="zoom:50%;" />

* æµç¨‹ï¼š
```cpp
** F --> B --> A --> nullLeft
** --> top(A) --> pop(A) -- > record(A) -->  nullRight
** -->top(B) --> pop(B) -->record(B) --> D --> C --> nullLeft
** --> top(C) --> pop(C) -->record(C) --> nullRight
** --> top(D) --> pop(D) --> record(D) --> E --> nullLeft
** -->top(E) --> pop(E) --> record(E) -->nullRight
** --> top(F) --> pop(F) --> record(F) --> G --> nullLeft
** -->top(G) --> pop(G) -- record(G) --> I --> nullLeft
** -->top(I) --> pop(I) --> record(I) --> H -->nullLeft
** --> top(H) --> pop(H) --> record(H) --> nullRight
** -->stkEMPTY && nullptr--> out 
```

##### Morriséå†

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        TreeNode *cur = root;
        while (cur != nullptr)
        {
            if (cur->left == nullptr)
            {
                // å¦‚æœå·¦å­æ ‘ä¸ºç©ºï¼Œåˆ™å°†å½“å‰èŠ‚ç‚¹çš„å€¼åŠ å…¥ç»“æœé›†ï¼Œå¹¶å°†å½“å‰èŠ‚ç‚¹æ›´æ–°ä¸ºå…¶å³å­èŠ‚ç‚¹
                ans.push_back(cur->val);
                cur = cur->right;  // å³å­æ ‘éå† / å›åˆ°ä¸Šä¸€ä¸ªå·¦å­æ ‘çš„èŠ‚ç‚¹
            }
            else
            {
                // å¦‚æœå·¦å­æ ‘éç©ºï¼Œåˆ™å¯»æ‰¾å‰é©±èŠ‚ç‚¹
                TreeNode *predecessor = cur->left;
                
                // æ‰¾åˆ°å³å­èŠ‚ç‚¹çš„å°½å¤´
                // pre->right != nullptr ä¸€èˆ¬è§¦å‘äºå³å­æ ‘æœ«ç«¯å°šæœªè¿æ¥ç¯èŠ‚ï¼Œå¯¹åº”ä¸‹æ–¹çš„if
                // pre->right != cur ä¸€èˆ¬è§¦å‘äºèŠ‚ç‚¹è½½å…¥ç¯èŠ‚ï¼Œå¯¹åº”ä¸‹æ–¹çš„else
                while (predecessor->right != nullptr && predecessor->right != cur) 
                {
                    predecessor = predecessor->right;
                }
                // å¦‚æœæ‰¾åˆ°çš„å‰é©±èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹ä¸ºç©ºï¼Œå°†å…¶å³å­èŠ‚ç‚¹æŒ‡å‘å½“å‰èŠ‚ç‚¹
                // ç„¶åå°†å½“å‰èŠ‚ç‚¹æ›´æ–°ä¸ºå…¶å·¦å­èŠ‚ç‚¹
                if (predecessor->right == nullptr)
                {
                    predecessor->right = cur;                 
                    cur = cur->left;
                }
                // å¦‚æœå‰é©±èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹ä¸ºå½“å‰èŠ‚ç‚¹ï¼Œè¯´æ˜å‰é©±èŠ‚ç‚¹å·²éå†å®Œ
                // å°†å…¶å³å­èŠ‚ç‚¹é‡ç½®ä¸ºç©ºï¼Œç„¶åå°†å½“å‰èŠ‚ç‚¹æ›´æ–°ä¸ºå…¶å³å­èŠ‚ç‚¹
                else
                {  
                    ans.push_back(cur->val);   
                    predecessor->right = nullptr; // åˆ é™¤è¿æ¥
                    cur = cur->right;
                }
            }
        }
        return ans;
    }
};
```

>è§£æ

* èµ·å§‹å’Œå‰åºmorriséå†ååˆ†ç›¸ä¼¼ï¼Œå”¯ä¸€ä¸åŒç‚¹åœ¨äºä¸­åºmorriséå†æ˜¯åœ¨ **`cur->left == nullptr`** æˆ– **`predecessor->right == cur`** æ—¶å°†å…ƒç´ åŠ å…¥åˆ°æ•°ç»„å°¾éƒ¨
    * åŸå› ï¼š
        * `cur->left == nullptr`,å¯¹äºè¿™ä¸€è¯­å¥ï¼Œæ˜¯å› ä¸ºå½“èŠ‚ç‚¹ä¸å†å­˜åœ¨ **å·¦å­èŠ‚ç‚¹** æ—¶ï¼Œæ ¹æ®ä¸­åºéå†çš„ **å…ˆå·¦å†æ ¹åå³** çš„åŸåˆ™ï¼Œå°†å·¦èŠ‚ç‚¹åŠ å…¥åˆ°æ•°ç»„ã€‚ç„¶åï¼Œä¼šè®©å®ƒå‰å¾€å³å­èŠ‚ç‚¹ï¼Œå³å­èŠ‚ç‚¹åœ¨ä¸ºæŠµè¾¾æœ€ç»ˆç‚¹æ—¶ **å¿…å®šå­˜åœ¨**ä¸”åªæœ‰å”¯ä¸€ä¸€ç§æƒ…å†µï¼šæ— è®ºå³å­èŠ‚ç‚¹æ ‘æœ‰å¤šé•¿ï¼Œå…¶ **ç»ˆç‚¹** å¿…å®šè¿æ¥`cur`è¿›å…¥å³å­èŠ‚ç‚¹å‰çš„ **ä¸Šä¸€ä¸ªèŠ‚ç‚¹**ï¼Œè¾¾åˆ°å›æº¯çš„æ•ˆæœ
           * æ³¨æ„ï¼Œå³å­èŠ‚ç‚¹æ ‘å¯èƒ½ä¼šå­˜åœ¨æŸäº›èŠ‚ç‚¹æœ‰ **å·¦æ”¯ç‚¹æ ‘**  çš„æƒ…å†µï¼Œæ­¤æ—¶ `pre` ä¼šå†æ¬¡å»ºç«‹è”ç³»
       *  `predecessor->right == cur`ï¼Œå¯¹äºè¿™ä¸€è¯­å¥ï¼Œè¡¨æ˜æ­¤æ—¶`cur`æ´¾å‡ºçš„`pre`æ£€æµ‹åˆ°åé¢çš„å­èŠ‚ç‚¹å·²ç»éå†è¿‡ï¼Œä¸éœ€è¦é‡å¤éå†ï¼Œæ­¤æ—¶ï¼Œä¼šè®°å½•èŠ‚ç‚¹å¹¶`cur=cur->right`
       

![500721818248791](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage500721818248791.jpg)

#### äºŒå‰æ ‘çš„ååºéå†
##### çŸ¥è¯†ç‚¹
* å…ˆéå†å·¦å­æ ‘
* ç„¶åéå†å³å­æ ‘
* æœ€åè®¿é—®æ ‘çš„æ ¹èŠ‚ç‚¹
* ä¾¿æ·è®°æ³•ï¼š
    * è‹¥å½“å‰èŠ‚ç‚¹ä¸º **éæ ¹èŠ‚ç‚¹** æˆ–è€… **è¯¥æ ¹èŠ‚ç‚¹ä¸‹çš„å­èŠ‚ç‚¹å·²éå†å®Œ** ï¼Œ åˆ™è®°å½•èŠ‚ç‚¹
    
##### é€’å½’
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void recursionTree(TreeNode* node , vector<int>& ans)
    {
        if(node==nullptr)
            return;
        
        recursionTree(node->left,ans);
        recursionTree(node->right,ans);
        ans.push_back(node->val);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> ans;
        recursionTree(root,ans);

        return ans;
    }
};
```

>è§£æ

```cpp
recursionTree(node->left,ans);
recursionTree(node->right,ans);
ans.push_back(node->val);
```
* å……åˆ†è¯´æ˜äº†åªæœ‰å½“å½“å‰èŠ‚ç‚¹ **éå†å®Œå®ƒçš„æ‰€æœ‰å­èŠ‚ç‚¹å** ï¼Œæ‰èƒ½è¢«è®°å½•ã€‚è€Œè®°å½•çš„é¡ºåºæ˜¯ï¼š
    * å…ˆå·¦å­èŠ‚ç‚¹ã€‚`recursionTree(node->left,ans);`è¿™è¯­å¥è¯´æ˜å·¦å­èŠ‚ç‚¹å…·æœ‰æœ€é«˜ä¼˜å…ˆçº§
    * å†å³å­èŠ‚ç‚¹
    * æœ€åæ ¹èŠ‚ç‚¹
* è‹¥æ ¹èŠ‚ç‚¹ **æ— ** å·¦å­èŠ‚ç‚¹ï¼Œåˆ™å…ˆè®°å½• **å³** å­èŠ‚ç‚¹    

##### è¿­ä»£
```cpp
class Solution
{
public:
    vector<int> postorderTraversal(TreeNode *root)
    {
        vector<int> res;
        if (root == nullptr)
        {
            return res;
        }

        stack<TreeNode *> stk;
        TreeNode *prev = nullptr;

        while (root != nullptr || !stk.empty())
        {
            while (root != nullptr) //æŠµè¾¾å·¦å­æ ‘ç»ˆç‚¹
            {
                stk.emplace(root);
                root = root->left;
            }
            //å›åˆ°ä¸Šä¸€èŠ‚ç‚¹
            root = stk.top();
            stk.pop();

            //è‹¥ä¸å­˜åœ¨å³å­èŠ‚ç‚¹ï¼Œåˆ™å°†èŠ‚ç‚¹è®°å½•ï¼Œå¹¶å°†prevæŒ‡å‘æ­¤èŠ‚ç‚¹ï¼ŒrootæŒ‡å‘ç©ºæŒ‡é’ˆç­‰å¾…ä¸‹æ¬¡å¾ªç¯è¢«æ ˆé¡¶èµ‹å€¼
            if (root->right == nullptr || root->right == prev)
            {
                res.emplace_back(root->val);
                prev = root;
                root = nullptr;
            }
            //è‹¥å­˜åœ¨å³å­èŠ‚ç‚¹ï¼Œåˆ™å°†å½“å‰èŠ‚ç‚¹åŠ å…¥æ ˆï¼Œå¹¶å¾€å³ç§»åŠ¨
            else
            {
                stk.emplace(root);
                root = root->right;
            }
        }
        return res;
    }
};

```
>è§£æ

* åœ¨æŠµè¾¾å·¦å­æ ‘ç»ˆç‚¹åï¼Œä¼šè¿”å›ä¸Šä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ­¤æ—¶åˆ†ä¸¤ç§æƒ…å†µ
    * â‘ æ­¤èŠ‚ç‚¹å­˜åœ¨å³å­æ ‘ï¼Œåˆ™ **é‡æ–°** å…¥æ ˆï¼Œå¹¶å¾€å³ç§»åŠ¨
    * â‘¡æ­¤èŠ‚ç‚¹ä¸å­˜åœ¨å³å­æ ‘æˆ–è€…æ­¤èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹ **å·²è¢«éå†**ï¼Œæ­¤æ—¶è®°å½•å€¼å¹¶ç§»åŠ¨`prev`å’Œ`root`
        * ä»ä½•å¾—çŸ¥å·²è¢«éå†ï¼Ÿ
            * `prev`æ˜¯`root`çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹ã€‚å½“`root->right==nullptr`æˆ–è€…åœ¨ä¸Šä¸€æ¬¡å¾ªç¯ä¸­å·²ç»å°†èŠ‚ç‚¹å€¼è®°å½•è¿‡ï¼Œéƒ½ä¼šè§¦å‘`prev=root`
        * ä¸ºä½•æ˜¯`root->right==prev`ï¼Œè€Œä¸æ˜¯`root->left==prev`
            * å› ä¸ºå³å­æ ‘èŠ‚ç‚¹åœ¨å·¦å­æ ‘èŠ‚ç‚¹è®¿é—®å®Œæ¯•ä¹‹åæ‰èƒ½è¢«è®¿é—®ï¼Œè€Œå·¦å­æ ‘æ— è®ºå¦‚ä½•éƒ½ä¼šè¿›å…¥åˆ°`ifåˆ¤æ–­`é‡Œï¼Œå³ä½¿å®ƒçš„æŸä¸ªèŠ‚ç‚¹å­˜åœ¨å³å­æ ‘ï¼Œæ­¤æ—¶ä¼šè¿›å…¥å³å­æ ‘å¹¶éå†ã€‚ç®€å•æ¥è¯´ï¼Œè¿™æ ·åˆ¤æ–­å¯ä»¥é˜²æ­¢æ¼æ‰å·¦å­æ ‘æŸä¸ªèŠ‚ç‚¹çš„å³å­æ ‘ï¼Œä¸”å·¦å­æ ‘æ‹¥æœ‰æœ€é«˜ä¼˜å…ˆçº§
* å½“è§¦å‘`root->right==nullptr`æˆ–è€…`root->right==prev`æ—¶ï¼Œéƒ½ä¼šåœ¨ä¸‹ä¸€æ¬¡å¾ªç¯ä¸­è·³è¿‡**å†…å±‚While**ï¼Œç›´è¾¾æ ˆé¡¶èµ‹å€¼

##### Morriséå†
```cpp
class Solution
{
public:
    void addPath(vector<int> &vec, TreeNode *node)
    {
        int count = 0;
        while (node != nullptr) //nodeä¸ºcur->left
        {
            ++count;
            vec.emplace_back(node->val); //ä»å·¦å­èŠ‚ç‚¹å¼€å§‹åŠ å…¥å…ƒç´ ï¼Œç›´è‡³å·¦å­èŠ‚ç‚¹çš„å³å­æ ‘ç»ˆç«¯
            node = node->right; //éå†å·¦å­èŠ‚ç‚¹çš„å³å­æ ‘
        }
        reverse(vec.end() - count, vec.end()); 
        //ç¿»è½¬ï¼Œå› ä¸ºæ­£ç¡®çš„æ’å…¥é¡ºåºæ˜¯ï¼šå³å­æ ‘å°¾ç«¯->å·¦å­èŠ‚ç‚¹(æ ¹èŠ‚ç‚¹)
        //å› ä¸ºæ˜¯emplace_backå°¾æ’æ³•ï¼Œæ‰€ä»¥ä»end()å¼€å§‹è®¡ç®—èŒƒå›´
    }

    vector<int> postorderTraversal(TreeNode *root)
    {
        vector<int> res;
        if (root == nullptr)
        {
            return res;
        }

        TreeNode *cur = root, *predecessor = nullptr;

        while (cur != nullptr)
        {
            predecessor = cur->left; //æ„å»ºå‰é©±èŠ‚ç‚¹ï¼Œè¿æ¥curå·¦å­èŠ‚ç‚¹çš„å³å­æ ‘ç»ˆç«¯-->cur
            if (predecessor != nullptr)
            {
                //å½“preçš„å³å­èŠ‚ç‚¹ä¸ºç©ºæˆ–è€…è¯¥å³å­æ ‘å·²è¢«è¿æ¥
                while (predecessor->right != nullptr && predecessor->right != cur)
                {
                    predecessor = predecessor->right;
                }
                //è‹¥æœªæ›¾ç»è¿æ¥
                if (predecessor->right == nullptr)
                {
                    predecessor->right = cur; //è¿æ¥
                    cur = cur->left; //curç»§ç»­éå†å½“å‰å­˜åœ¨çš„å·¦å­æ ‘
                    continue;
                }
                else //è‹¥æ›¾ç»è¿æ¥è¿‡
                {
                    predecessor->right = nullptr; //æ¶ˆé™¤è¿æ¥æŒ‡é’ˆ
                    addPath(res, cur->left); //ç¿»è½¬[å·¦å­èŠ‚ç‚¹-->å·¦å­èŠ‚ç‚¹çš„å³å­æ ‘ç»ˆç‚¹]å…ƒç´ 
                }
            }
            cur = cur->right; 
            //â‘ å½“curæŠµè¾¾å·¦å­æ ‘çš„ç»ˆç‚¹æ—¶ï¼Œé€šè¿‡preåˆ›é€ çš„é€šé“ï¼Œå›åˆ°å·¦å­æ ‘èµ·ç‚¹çš„ä¸Šä¸€ä¸ªleftè¿æ¥ç‚¹
            //â‘¡å½“curé€šè¿‡preåˆ›é€ çš„é€šé“å›åˆ°ä¸Šä¸€ä¸ªèŠ‚ç‚¹åï¼Œé€šè¿‡è¿™ä¸ªè¯­å¥è¿”å›ä¸Šä¸€ä¸ªèŠ‚ç‚¹æˆ–è€…è¿›å…¥å³å­æ ‘
        }
        addPath(res, root); 
        //è¿™é‡Œç¿»è½¬çš„æ˜¯Treeçš„æœ€å³å­æ ‘ï¼Œåœ¨è¿™ä¸€æ¡å­æ ‘ä¸­ï¼Œcurä¼šåœ¨æœ«ç«¯æŠµè¾¾nullptré€€å‡ºå¾ªç¯
        //å› æ­¤æœ€å³å­æ ‘çš„è¿™æ®µå€¼éœ€è¦ä»[æ ¹èŠ‚ç‚¹å¼€å§‹-->æœ€å³å­æ ‘æœ«ç«¯]åŠ å…¥æ•°ç»„ç„¶åç¿»è½¬
        
        return res;
    }
};

```
>~~åªå¯æ„ä¼šï¼Œä¸å¯è¨€ä¼ ï¼~~

* å¯¹äºæœ€åˆæ ¹èŠ‚ç‚¹çš„æ‰€æœ‰å·¦å­æ ‘è€Œè¨€ï¼Œæ˜¯ä¼˜å…ˆè¢«åŠ å…¥åˆ°æ•°ç»„çš„ã€‚ä½†å®ƒä»¬çš„åŠ å…¥ **å¹¶é** å‡ ä¸ªå…ƒç´ ä¸€èµ·å‡å¦‚ç„¶åç¿»è½¬ï¼Œè€Œæ˜¯ä¸€ä¸ªä¸€ä¸ªåŠ å…¥ã€‚å› ä¸ºå¯¹äº **preæœªæ›¾éå†è¿‡çš„å·¦å­æ ‘è€Œè¨€** ï¼Œæ€»å­˜åœ¨`if (predecessor->right == nullptr)`
* è€Œå¯¹äºæ‰€æœ‰å³å­æ ‘è€Œè¨€ï¼Œå®ƒä»¬éƒ½æ˜¯æ•´æ£µæ ‘åŠ å…¥çš„ï¼Œç„¶åç¿»è½¬
* å¯¹äºæœ€å³å­æ ‘è€Œè¨€ï¼Œåœ¨`while`å¾ªç¯é‡Œæ²¡æœ‰è¢«åŠ å…¥ï¼Œéœ€è¦åœ¨é€€å‡ºå¾ªç¯åé‡æ–°æ‰§è¡Œä¸€æ¬¡`addPath`

~~ä¸ºä»€ä¹ˆä¼šæœ‰äººèƒ½å†™å‡ºè¿™ä¹ˆç‰›é€¼çš„ç®—æ³•ï¼Ÿï¼Ÿ~~

![191241918236658](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage191241918236658.jpg)

#### äºŒå‰æ ‘çš„å±‚åºéå†
![352934511230366](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage352934511230366.png)

##### çŸ¥è¯†ç‚¹
>ä½•ä¸ºå±‚åºéå†

*å°†æ¯ä¸€å±‚çš„å…ƒç´  **ä»å·¦åˆ°å³** ä¾æ¬¡åŠ å…¥æ•°ç»„
<img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage190391614249494.jpg" alt="190391614249494" style="zoom:50%;" />

##### å¹¿åº¦ä¼˜å…ˆæœç´¢[queue][è¿­ä»£]

```cpp
class Solution
{
public:
    vector<vector<int>> levelOrder(TreeNode *root)
    {
        vector<vector<int>> ret;
        if (!root)
        {
            return ret;
        }

        queue<TreeNode *> q; //queueä¸ºé˜Ÿåˆ—ï¼Œå…ˆè¿›å…ˆå‡ºï¼Œå‡ä»åº•éƒ¨è¿›å…¥ï¼Œé¡¶éƒ¨å‡º
        q.push(root); //å°†æ ¹èŠ‚ç‚¹æ”¾å…¥q
        while (!q.empty()) 
        {
            int currentLevelSize = q.size();   //è¿™ä¸€å±‚çš„èŠ‚ç‚¹ä¸ªæ•°
            ret.push_back(vector<int>());  //æ–°å¢retå®¹å™¨çš„æœ€åä¸€è¡Œ
            for (int i = 1; i <= currentLevelSize; ++i)
            {
                auto node = q.front();  //ä»å‰é¢æ‹¿å–ä¸€ä¸ªæŒ‡é’ˆ
                q.pop();  //å°†åˆšæ‹¿å–çš„æŒ‡é’ˆä»é˜Ÿåˆ—é‡Œå¼¹å‡º
                ret.back().push_back(node->val);  //åœ¨retçš„æ–°å¢çš„æœ€åä¸€è¡Œçš„å°¾éƒ¨æ·»åŠ node->val
                if (node->left) //å½“nodeå­˜åœ¨å·¦å­èŠ‚ç‚¹
                    q.push(node->left);  //å…¥é˜Ÿå·¦å­èŠ‚ç‚¹
                if (node->right) //å½“nodeå­˜åœ¨å³å­èŠ‚ç‚¹
                    q.push(node->right); //å…¥é˜Ÿå³å­èŠ‚ç‚¹
            }
        }

        return ret;
    }
};
```
>è§£æ

* è¿™é¢˜çš„æ ¸å¿ƒæ€æƒ³å°±æ˜¯ï¼Œåœ¨å½“å‰å±‚é‡Œï¼Œå°†ä¸‹ä¸€å±‚çš„èŠ‚ç‚¹æŒ‡é’ˆ **ä»å·¦åˆ°å³** ä¾æ¬¡åŠ å…¥åˆ°é˜Ÿåˆ—é‡Œï¼Œåˆ©ç”¨é˜Ÿåˆ— **å…ˆè¿›å…ˆå‡º** çš„ç‰¹æ€§ï¼Œå…ˆåŠ å…¥çš„æŒ‡é’ˆä¼šåœ¨ä¸‹ä¸€æ¬¡whileå¾ªç¯ä¼˜å…ˆè®°å½•å…ƒç´ 
<img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage443451614246049.gif" alt="443451614246049" style="zoom:50%;" />

###### queueçš„æ‹“å±•

 * queueæ˜¯STLæä¾›çš„ä¸€ç§å®¹å™¨ï¼Œç”¨äºè¡¨ç¤ºé˜Ÿåˆ—ç»“æ„ã€‚å®ƒé€šå¸¸è¢«å®ç°ä¸ºä¸€ç§é€‚é…å™¨ï¼Œåº•å±‚ä½¿ç”¨åˆ«çš„å®¹å™¨ï¼Œä¾‹å¦‚dequeæˆ–listæ¥å®ç°é˜Ÿåˆ—çš„åŸºæœ¬æ“ä½œã€‚
* é˜Ÿåˆ—æ˜¯ä¸€ç§$FIFO$ï¼ˆå…ˆè¿›å…ˆå‡ºï¼‰æ•°æ®ç»“æ„ã€‚é˜Ÿåˆ—æ”¯æŒåœ¨é˜Ÿåˆ—çš„ **æœ«å°¾** æ·»åŠ å…ƒç´ å’Œåœ¨é˜Ÿåˆ—çš„ **å‰ç«¯** åˆ é™¤å…ƒç´ ã€‚è¢«æ·»åŠ åˆ°é˜Ÿåˆ—ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ€»æ˜¯ç¬¬ä¸€ä¸ªè¢«åˆ é™¤ã€‚
* å®šä¹‰ï¼š
    * `queue <TypeName> Name;`
* queueå¸¸ç”¨çš„åŸºæœ¬æ“ä½œæœ‰ä»¥ä¸‹å‡ ç§ï¼š
    * `empty()`ï¼šè¿”å›queueæ˜¯å¦ä¸ºç©ºã€‚
    * `size()`ï¼šè¿”å›queueä¸­å…ƒç´ çš„æ•°é‡ã€‚
    * `front()`ï¼šè¿”å›queueä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚
    * `back()`ï¼šè¿”å›queueä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚
    * `push()`ï¼šåœ¨é˜Ÿåˆ—çš„æœ«å°¾æ·»åŠ ä¸€ä¸ªå…ƒç´ ã€‚
    * `pop()`ï¼šåˆ é™¤é˜Ÿåˆ—ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚
        * å…¶ä¸­ï¼Œfront()ã€back()ã€push()å’Œpop()å¯¹queueçš„åº•å±‚å®¹å™¨å®ç°è¿›è¡Œäº†å°è£…ï¼Œä½¿å¾—å®ƒä»¬åªèƒ½åœ¨é˜Ÿåˆ—çš„å‰åç«¯è¿›è¡Œæ“ä½œã€‚
* queueä¸èƒ½åœ¨ä¸­é—´æˆ–éšæ„ä½ç½®æ·»åŠ æˆ–åˆ é™¤å…ƒç´ ï¼Œåªèƒ½åœ¨é˜Ÿåˆ—çš„æœ«å°¾æ·»åŠ å…ƒç´ ï¼Œåœ¨é˜Ÿåˆ—çš„å‰ç«¯åˆ é™¤å…ƒç´ ã€‚è¿™æ˜¯ç”±äºé˜Ÿåˆ—çš„æ•°æ®ç»“æ„ç‰¹æ€§æ‰€å†³å®šçš„ã€‚
* queueä¸æ”¯æŒè¿”å› **ä¸­é—´æŸä¸€ä¸ª** å…ƒç´ ï¼Œä»…æ”¯æŒè¿”å›å¤´å°¾å…ƒç´ 

##### æ·±åº¦ä¼˜å…ˆæœç´¢[é€’å½’]
```cpp
//å±‚æ¬¡éå†-æ·±åº¦ä¼˜å…ˆæœç´¢
    vector<vector<int>> levelOrder2(TreeNode *root)
    {
        vector<vector<int>> ret;
        if (!root)
        {
            return ret;
        }

        dfs(root, 0, ret);
        return ret;
    }

    void dfs(TreeNode *root, int level, vector<vector<int>> &ret)
    {
        if (level == ret.size()) //å½“levelç­‰äºretçš„è¡Œæ•°æ—¶ï¼Œæ–°å¢ä¸€è¡Œ
        {
            ret.push_back(vector<int>());
        }

        ret[level].push_back(root->val); //å°†å½“å‰èŠ‚ç‚¹çš„å€¼æ”¾å…¥retçš„levelè¡Œçš„å°¾éƒ¨
        if (root->left) //å½“rootæ‹¥æœ‰å·¦æ”¯ç‚¹æ—¶
        {
            dfs(root->left, level + 1, ret); //é€’å½’ä¸‹ä¸€å±‚
        }
        if (root->right) //å…ˆå·¦åå³
        {
            dfs(root->right, level + 1, ret);
        }
    }
```
>è§£æ

* æ·±åº¦ä¼˜å…ˆæœç´¢å®è´¨ä¸Šæ˜¯å°†äºŒå‰æ ‘æ‘†æˆé˜¶æ¢¯å‹
<img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage582210014248792.jpg" alt="582210014248792" style="zoom:50%;" />
* å®ƒçš„éå†è§„åˆ™æ˜¯ï¼š
    * ä¼˜å…ˆåˆ—éå†ï¼Œåœ¨éå†çš„è¿‡ç¨‹ä¸­è®°å½•èŠ‚ç‚¹ `if (root->left)`
    * æŠµè¾¾åˆ—éå†çš„ **å°¾éƒ¨**ï¼ˆå¦‚3ï¼‰åï¼Œå¼€å§‹æ£€æµ‹æ—¶å¦æœ‰ **å³æ”¯ç‚¹** `if (root->right)`ï¼Œè‹¥æœ‰ï¼Œåˆ™ä»¥è¿™ä¸ªå³æ”¯ç‚¹ä¸º **èµ·å§‹** ï¼Œ å¼€å§‹æ–°ä¸€è½®åˆ—éå†
* æ³¨æ„ï¼š
    * `dfs`ä¸€èˆ¬æŒ‡$DFS(Deep FirstSearch)$ï¼Œä¹Ÿç§°ä¸ºæ·±åº¦ä¼˜å…ˆæœç´¢
    * ` if (level == ret.size())`æ—¶ï¼Œæ–°å¢ä¸€è¡Œè‡³å°¾éƒ¨ï¼Œé˜²æ­¢ä¸‹ä¸€æ¬¡é€’å½’`level+1`æ—¶æº¢å‡º

##### å¯¹BFS(å¹¿åº¦ä¼˜å…ˆæœç´¢)å’ŒDFS(æ·±åº¦ä¼˜å…ˆæœç´¢)çš„å›¾è§£
<img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage438731514256825.gif" alt="438731514256825" style="zoom:50%;" />

#### äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦

![559060715241803](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage559060715241803.png)

##### æ·±åº¦ä¼˜å…ˆæœç´¢DFS[é€’å½’]
```cpp
// äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦-æ·±åº¦ä¼˜å…ˆæœç´¢   
    int maxDepthDfs(TreeNode *root)
    {
        if (root == nullptr)
            return 0;
        int maxLen = 1, len = 1;
        dfs(maxLen, len, root);
        return maxLen;
    }
    void dfs(int &maxLen, int len, TreeNode *node)
    {
        if (node->left) // è‹¥nodeæœ‰å·¦æ”¯ç‚¹ï¼Œåˆ™é€’å½’ä¸‹ä¸€å±‚ï¼Œå¹¶å°†len+1
            dfs(maxLen, len + 1, node->left);
        maxLen = max(maxLen, len);

        if (node->right) // åŒç†ï¼Œå…ˆå·¦åå³
            dfs(maxLen, len + 1, node->right);
        maxLen = max(maxLen, len);
    }
```

##### å¹¿åº¦ä¼˜å…ˆæœç´¢BFS[queue]
```cpp
// äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦-å¹¿åº¦ä¼˜å…ˆæœç´¢
    int maxDepthBfs(TreeNode *root)
    {
        if (root == nullptr)
            return 0;

        queue<TreeNode *> q;
        q.push(root);
        int maxLen = 0;
        while (!q.empty())
        {
            ++maxLen; // æ¯æ¬¡å¾ªç¯ï¼Œå±‚æ•°+1
            int len = q.size();

            for (int i = 1; i <= len; ++i)
            {
                auto node = q.front();
                q.pop();
                if (node->left)
                    q.push(node->left);
                if (node->right)
                    q.push(node->right);
            }
        }
        return maxLen;
    }
```
>è§£æ

* å’Œå±‚æ¬¡éå†çš„BFSå·®ä¸å¤šï¼Œåœ¨æ¯ä¸€æ¬¡ **è¿›å…¥`while`å¾ªç¯** éƒ½ä»£è¡¨è¿™è¿™ä¸€å±‚æ˜¯å­˜åœ¨çš„ï¼Œæ‰€ä»¥ `++maxLen`
    * å”¯ä¸€çš„ä¸åŒç‚¹æ˜¯å°‘äº†æ–°å¢è¡Œè¯­å¥`ret.push_back(vector<int>());`

#### å¯¹ç§°äºŒå‰æ ‘
![464480212230367](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage464480212230367.png)

##### å¹¿åº¦ä¼˜å…ˆæœç´¢BFS[è¿­ä»£][queue]
```cpp
//å¯¹ç§°äºŒå‰æ ‘
    bool isSymmetric(TreeNode *root)
    {
        return bfsSymmetric(root, root);
    }
    bool bfsSymmetric(TreeNode *lf, TreeNode *rf)
    {
        queue<TreeNode *> q;
        q.push(lf);
        q.push(rf);
        bool sw = 1;
        while (sw && !q.empty())
        {
            lf = q.front();
            q.pop();
            rf = q.front();
            q.pop();

            if (!lf && !rf)                           // å½“lfä¸ºç©ºä»¥åŠrfä¸ºç©ºæ—¶
                continue;                             // è·³è¿‡ä»¥ä¸‹qçš„å­˜å‚¨
            if ((!lf || !rf) || (lf->val != rf->val)) // åªè¦lfä¸ºç©ºæˆ–è€…rfä¸ºç©ºæˆ–è€…valå€¼ä¸ç›¸ç­‰ï¼Œåˆ™ä¸å¯¹ç§°
                return false;

            //ä»¥å¯¹ç§°å¼ç»“æ„æ¨å…¥
            q.push(lf->left); // å¯èƒ½ä¼šæ¨å…¥nullptr
            q.push(rf->right);

            q.push(lf->right);
            q.push(rf->left);
        }

        return true;
    }
```

>è§£æ

ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢çš„å½¢å¼å¯¹æ¯ä¸€å±‚çš„å¯¹ç§°èŠ‚ç‚¹è¿›è¡Œæ¯”è¾ƒ

##### æ·±åº¦ä¼˜å…ˆæœç´¢DFS[é€’å½’]
```cpp
// å¯¹ç§°äºŒå‰æ ‘
    bool check(TreeNode *p, TreeNode *q)
    {
        if (!p && !q) //è‹¥åœ¨ç¬¬ä¸€ä¸ªcheck()ä¸­åˆ¤æ–­æ­£ç¡®ï¼Œåˆ™è¡¨ç¤ºä¸¤ä¸ªèŠ‚ç‚¹å‡ä¸ºå·¦ã€å³æ”¯ç‚¹ï¼Œå¯ä»¥è¿›è¡Œä¸‹ä¸€ä¸ªcheckçš„åˆ¤æ–­
            return true;
        if (!p || !q)
            return false;
        return p->val == q->val && check(p->left, q->right) && check(p->right, q->left);
    }
    bool isSymmetric(TreeNode *root)
    {
        return check(root, root);
    }

```
>è§£æ

* æ­¤é¢˜çš„é€’å½’å‡½æ•°åˆ†ä¸ºä¸‰ç§æƒ…å†µ
    * ä¼ é€’çš„ä¸¤ä¸ªèŠ‚ç‚¹å‡ä¸º`nullptr`
        * è‹¥æ­¤æ—¶æ˜¯`check(p->left, q->right)`ï¼Œåˆ™è¿›è¡Œä¸‹ä¸€ä¸ª`check(p->right, q->left)`
        * è‹¥æ­¤æ—¶æ˜¯æœ€åä¸€ä¸ª`check()`ï¼Œåˆ™è¡¨ç¤ºå‡å·²æŠµè¾¾ç»ˆç‚¹ä¸”å †æˆï¼Œæ­¤æ—¶è¿”å›`true`
    * ä¼ é€’çš„ä¸¤ä¸ªèŠ‚ç‚¹æœ‰ä¸€ä¸ª**ä¸ä¸º`nullptr`**ï¼Œæ­¤æ—¶è¿”å›`false`ï¼Œä¸”ä¸ä¼šå†æ¬¡è¿›è¡Œé€’å½’
        * æ³¨æ„ï¼Œè™½ç„¶ `(!p || !q)`ä¸­ä¹Ÿå­˜åœ¨pã€qå‡ä¸º`nullptr`çš„æƒ…å†µï¼Œä½†æ˜¯è¿™ç§æƒ…å†µåœ¨å‰é¢çš„ifåˆ¤æ–­é‡Œå·²ç»è¢«è¿”å›true
    * ä¼ é€’çš„ä¸¤ä¸ªèŠ‚ç‚¹å‡ **ä¸ä¸º`nullptr`** 
        * æ­¤æ—¶å…ˆæ¯”è¾ƒå®ƒä»¬çš„å€¼
        * è‹¥å€¼ç›¸ç­‰ï¼Œåˆ™æ¯”è¾ƒå®ƒä»¬çš„å¯¹ç§°ä½ç½®

#### è·¯å¾„æ€»å’Œ
![245293514230367](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage245293514230367.png)
##### æ·±åº¦ä¼˜å…ˆæœç´¢DFS[é€’å½’]
###### åšæ³•ä¸€
```cpp
// è·¯å¾„æ€»å’Œ
    bool check(TreeNode *node, int sum, int target)
    {
        bool sw = false;
        if (sum == target && (node->left == nullptr && node->right == nullptr))
            sw = true;

        if (node->left && !sw) //å½“å­˜åœ¨node->leftä¸”æ— ç¬¦åˆtargetçš„æƒ…å†µä¸‹
            sw = check(node->left, sum + node->left->val, target);
        if (node->right && !sw)  //åŒç†
            sw = check(node->right, sum + node->right->val, target);

        return sw;
    }
    bool hasPathSum(TreeNode *root, int targetSum)
    {
        if (root == nullptr)
            return false;
        int sum = root->val;
        return check(root, sum, targetSum);
    }
```
> è§£æ

* è‹¥å­˜åœ¨æŸè·¯å¾„ç¬¦åˆæ¡ä»¶ï¼Œåˆ™`sw=true`ï¼Œæ­¤æ—¶ä¼šè·³è¿‡ä¸‹é¢çš„ä¸¤ä¸ª`ifç§»åŠ¨`è¯­å¥ï¼Œä¸€ç›´`return true`

###### åšæ³•äºŒ  
```cpp
    bool hasPathSum(TreeNode *root, int sum)
    {
        if (root == nullptr)
        {
            return false;
        }
        if (root->left == nullptr && root->right == nullptr)
        {
            return sum == root->val;
        }
        return hasPathSum(root->left, sum - root->val) ||
               hasPathSum(root->right, sum - root->val);
    }
```
>è§£æ

* æ­¤æ–¹æ³•ä½¿ç”¨äº†$surplus$å‰©ä½™å€¼ï¼Œé€šè¿‡é€‰å‡º **å¶å­èŠ‚ç‚¹** æ¥åˆ¤æ–­æ˜¯å¦å’Œ`surplus(sum)`ç›¸ç­‰ï¼Œè‹¥ç›¸ç­‰ï¼Œåˆ™ä¼šä¸€ç›´è¿”å›`true`ï¼Œè€Œ`||`çš„ç‰¹æ€§ï¼šå½“ä¸€æ–¹ä¸º`true`æ—¶ï¼Œä¼š **è·³è¿‡** ä¹‹åçš„åˆ¤å®šï¼Œç›´æ¥è¿”å›`true`

##### å¹¿åº¦ä¼˜å…ˆæœç´¢BFS[queue]
```cpp
//è·¯å¾„æ€»å’Œ-å¹¿åº¦ä¼˜å…ˆæœç´¢
    bool hasPathSumBfs(TreeNode *root , int target)
    {
        if(root==nullptr)
            return false;
        queue<TreeNode*> qNode; 
        queue<int> qSum;

        qNode.push(root);
        qSum.push(root->val);
        while(!qNode.empty())
        {
            int len = qNode.size();

            for(int i=1;i<=len;++i)
            {
                auto node = qNode.front(); //è·å–å¹¶å¼¹å‡ºèŠ‚ç‚¹æŒ‡é’ˆ
                qNode.pop();
                auto sum = qSum.front();  //è·å–å¹¶å¼¹å‡ºèŠ‚ç‚¹æ€»å€¼
                qSum.pop();

                if(node->left==nullptr && node->right==nullptr && sum==target)
                    return true;
                if(node->left) //å½“å­˜åœ¨å·¦å­èŠ‚ç‚¹æ—¶ï¼Œå­˜å‚¨æ€»å€¼å’Œå·¦å­èŠ‚ç‚¹æŒ‡é’ˆ
                {
                    qSum.push(sum+node->left->val);
                    qNode.push(node->left);
                }
                if(node->right)  //åŒç†
                {
                    qSum.push(sum+node->right->val);
                    qNode.push(node->right);
                }
            }
        }

        return false;        
    }
```
>è§£æ

* æ­¤ç®—æ³•å¹¶ä¸èƒ½åšåˆ° **å®æ—¶åˆ¤æ–­ç›¸ç­‰** ï¼Œ ä¸ºäº†é…åˆ`qNode`ï¼Œå­˜å‚¨æ€»å€¼ä¹Ÿåªèƒ½ä½¿ç”¨`queue`å·²è¾¾åˆ°åŒæ­¥çš„æ•ˆæœã€‚è€Œ`queue`çš„ç‰¹æ€§æ—¶ **å…ˆè¿›åå‡º** ï¼Œå› æ­¤å¹¶ä¸èƒ½ç¬¬ä¸€æ—¶é—´ç­‰åˆ°ç­”æ¡ˆï¼Œå¾€å¾€éœ€è¦åœ¨ä¸‹ä¸€ä¸ª `whileå¾ªç¯` é‡Œæ‰èƒ½åˆ¤æ–­
* å¹¿åº¦ä¼˜å…ˆæœç´¢å¾—åˆ°çš„è·¯å¾„æ€»å’Œä¸º **æœ€çŸ­è·¯å¾„**

#### ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘
![226535020230368](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage226535020230368.png)
##### é€’å½’
```cpp
#include <iostream>
#include <vector>
#include <unordered_map>

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution
{
    unordered_map<int, int> myMap;
    int pIndex;

public:
    TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder)
    {
        pIndex = postorder.size() - 1;
        int index = 0;
        for (auto &val : inorder) // è®°å½•å“ˆå¸Œå€¼ï¼Œå‰åºå€¼-->ä¸‹æ ‡ï¼Œæ–¹ä¾¿é€šè¿‡å‰åºå€¼é”å®šèŒƒå›´
            myMap[val] = index++;
        return helper(0, pIndex, inorder, postorder);
    }

    TreeNode *helper(int left, int right, vector<int> &inorder, vector<int> &postorder)
    {
        if(left>right)
            return nullptr;
        int val = postorder[pIndex--];
        TreeNode *root = new TreeNode(val); // å»ºç«‹èŠ‚ç‚¹å¹¶é™„ä¸Šå€¼

        int index = myMap[val]; // å¯»æ‰¾ä¸‹æ ‡ï¼Œç¡®å®šèŒƒå›´

        // ç”±äºæ˜¯ä½¿ç”¨ååºéå†æ•°ç»„ä»åå¾€å‰ç¡®å®šæ ¹èŠ‚ç‚¹çš„ï¼Œæ‰€æœ‰éœ€è¦ä»å³è¾¹å¼€å§‹é€’å½’
        root->right = helper(index + 1, right, inorder, postorder);
        root->left = helper(left, index - 1, inorder, postorder);

        return root;
    }
};
```

>è§£æ

<img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage591185020248794.png" alt="591185020248794" style="zoom: 33%;" />

* è¿™é¢˜çš„æ€è·¯æ˜¯æ ¹æ®ååºéå†åˆ—è¡¨çš„ç‰¹æ€§ç¡®å®šæ ¹èŠ‚ç‚¹
    * ååºåˆ—è¡¨çš„éå†é¡ºåºæ˜¯ `å·¦èŠ‚ç‚¹-->å³èŠ‚ç‚¹-->æ ¹èŠ‚ç‚¹`ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæœ€åä¸€ä¸ªä¸€å®šæ˜¯ **æœ€åˆçš„æ ¹èŠ‚ç‚¹**
    * åç»­åˆ—è¡¨çš„ **ä»å³å¾€å·¦** å¯¹åº”çš„èŠ‚ç‚¹ç‰¹æ€§é¡ºåºæ˜¯ `æ ¹èŠ‚ç‚¹-->å³èŠ‚ç‚¹-->å·¦èŠ‚ç‚¹` ï¼Œ ä¸æ­£åºéå†ç›¸åï¼Œå®ƒçš„ **å³å…·æœ‰æœ€é«˜ä¼˜å…ˆåº¦**
        * ä¸¾ä¸ªä¾‹å­

```python
//     1
//    / \
//   2   3
//  / \   \
// 4   5   6
//    / \
//   7   8
//  / \
// 9  10

// äºŒå‰æ ‘çš„ååºéå†ä¸ºï¼š4 9 10 7 8 5 2 6 3 1
// äºŒå‰æ ‘çš„å‰åºéå†ä¸ºï¼š1 2 4 5 7 9 10 8 3 6
// äºŒå‰æ ‘çš„ä¸­åºéå†ä¸ºï¼š4 2 9 7 10 5 8 1 3 6

```

* æ ¹æ®ç‰¹æ€§ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ååºåˆ—è¡¨å’Œä¸­åºåˆ—è¡¨åŒ¹é…çš„å€¼ç¡®å®šèŒƒå›´
    * å¯¹äº`ä¸­åº[1,3,5,7,9] | ååº[x,x,x,x,5]` æˆ‘ä»¬å¯ä»¥ç¡®å®š`æ ¹`çš„å€¼æ˜¯5ã€‚å› æ­¤æ ¹æ®ä¸­åºéå†é¡ºåº`å·¦-->ä¸­-->å³`å¯ä»¥åˆ†å‡ºèŒƒå›´`å·¦å­æ ‘[1,3] | å³å­æ ‘[7,9]`ï¼Œæ ¹æ®ä¸æ–­åœ°é€’å½’ç¼©å°èŒƒå›´ã€‚å½“èŒƒå›´ä¸å­˜åœ¨äº†`left>right`,å°±ä»£è¡¨è¿™ä¸ªèŠ‚ç‚¹ **æ— å·¦å­èŠ‚ç‚¹æˆ–å³å­èŠ‚ç‚¹** ï¼Œ æ­¤æ—¶`return nullptr`
    
* ä¸ºä½•æ˜¯å…ˆ`root->right`
    * è¿™ä¸**ååºåˆ—è¡¨**çš„éå†æ–¹å¼æœ‰å…³ã€‚æˆ‘ä»¬è®¾å®šäº†ä¸€ä¸ªä¸‹æ ‡å€¼`pIndex`ï¼Œå®ƒä¸€å¼€å§‹æŒ‡å‘å°¾éƒ¨ï¼Œç„¶åé€æ¸å‘å‰ã€‚å› æ­¤ï¼Œ`val`çš„å€¼ä¼˜å…ˆåœ¨å³å­æ ‘ï¼Œè€Œåæ‰åœ¨å·¦å­æ ‘ã€‚è¿˜æ˜¯åè¿‡æ¥çš„åŸç†:    `æ ¹èŠ‚ç‚¹-->å³èŠ‚ç‚¹-->å·¦èŠ‚ç‚¹`
      
##### è¿­ä»£
```cpp
TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder)
{
    if (postorder.size() == 0)
    {
        return nullptr;
    }
    auto root = new TreeNode(postorder[postorder.size() - 1]);
    auto s = stack<TreeNode *>();
    s.push(root);
    int inorderIndex = inorder.size() - 1;
    for (int i = int(postorder.size()) - 2; i >= 0; i--)
    {
        int postorderVal = postorder[i]; //posterorderValæ€»æ˜¯ä¸ºnode->valå‰ä¸€ä¸ªèŠ‚ç‚¹
        auto node = s.top();
        if (node->val != inorder[inorderIndex])
        {
            node->right = new TreeNode(postorderVal);
            s.push(node->right);
        }
        else
        {
            while (!s.empty() && s.top()->val == inorder[inorderIndex])
            {
                node = s.top();//nodeä¸ºs.top()çš„çˆ¶èŠ‚ç‚¹
                s.pop();
                inorderIndex--;
            }
            node->left = new TreeNode(postorderVal); //
            s.push(node->left);
        }
    }
    return root;
}
```
>è§£æ

ä¸­åºéå†=`[15 ,  9 , 10 , 3 , 20 , 5 , 7 ,  8 , 4]`
ååºéå†=`[15 , 10 ,  9 , 5 ,  4 , 8 , 7 , 20 , 3]`
```python
        3
       / \
      9  20
     / \   \
    15 10   7
           / \
          5   8
               \
                4


```


* ä¸­åºéå†çš„é¡ºåº : å·¦ -> æ ¹ -> å³ ã€‚ åè¿‡æ¥ : `å³->æ ¹->å·¦`
* ååºéå†çš„é¡ºåº : å·¦ -> å³ -> æ ¹ ã€‚ åè¿‡æ¥ : `æ ¹->å³->å·¦`
    * å³å®ƒä»¬åœ¨åè¿‡æ¥éå†çš„æƒ…å†µä¸‹`å·¦èŠ‚ç‚¹`çš„ä¼˜å…ˆçº§æœ€ä½
* `postorderVal`æ€»æ˜¯æ¯”`node->val`é¢†å…ˆä¸€ä¸ªèŠ‚ç‚¹å€¼ï¼Œå³`node`å……å½“ç€ **çˆ¶èŠ‚ç‚¹çš„ä½œç”¨**
* åœ¨`else`åˆ¤æ–­ä¸­ï¼Œ`node`æ€»æ˜¯é¢†å…ˆ`s.top()`ï¼Œå› ä¸ºå½“`while`æ¡ä»¶ç¬¦åˆåï¼Œä¾¿é€€å‡ºå¾ªç¯
* `stack s`æ‰€å­˜å‚¨çš„éƒ½æ˜¯ **å½“å‰èŠ‚ç‚¹çš„ç¥–å…ˆèŠ‚ç‚¹**
* éœ€ç»“åˆé€’å½’çš„æƒ³æ³•ï¼šå½“ååºéå†çš„æŸä¸ªèŠ‚ç‚¹å€¼ä¸å‰åºèŠ‚ç‚¹å€¼ç›¸ç­‰æ—¶ï¼Œåœ¨è¿™ä¸ªèŠ‚ç‚¹çš„èŒƒå›´é‡Œï¼Œå·¦è¾¹æ˜¯å·¦æ”¯ç‚¹ï¼Œå³è¾¹æ˜¯å³æ”¯ç‚¹ã€‚æ³¨æ„ï¼Œéœ€è¦ç†æ¸…èŒƒå›´çš„æ¦‚å¿µï¼š
    * èŒƒå›´æ˜¯ **ä¸æ–­ç¼©å°çš„**ï¼Œå¦‚åœ¨`ä¸­åº=[1,3,5,7,9]`ä¸­ï¼Œååºçš„æœ€åä¸€ä½æ˜¯`5`ï¼Œåˆ™`[1,3]`å‡ä¸º5çš„ **å·¦å­æ ‘èŠ‚ç‚¹**ï¼Œ`[7,9]`å‡ä¸º **å³å­æ ‘èŠ‚ç‚¹**ã€‚è‹¥å€’æ•°ç¬¬äºŒä½æ˜¯`9`ï¼Œåˆ™`[7]`ä¸º9çš„ **å·¦å­æ ‘èŠ‚ç‚¹** ï¼Œ `nullptr`ä¸º `å³å­æ ‘èŠ‚ç‚¹`ã€‚è¿™ä¸ªèŒƒå›´æ˜¯æ ¹æ®**çˆ¶èŠ‚ç‚¹**ä¸æ–­ç¼©å°çš„ï¼Œæ¯å½“ç¡®ç«‹äº†ä¸€ä¸ªçˆ¶èŠ‚ç‚¹ï¼Œåˆ™å¯ä»¥ç†è§£ä¸ºä¸€æŠŠåˆ€ï¼Œå°†è¿™ä¸ªåˆ—è¡¨åˆ‡æˆä¸¤ä»½
    * å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä»ä¸­è·å¾—ç‰¹æ€§ï¼šå½“å­˜åœ¨`node->val != inorder[inorderIndex]`æ—¶ï¼Œå› ä¸ºä¸­åºåˆ—è¡¨è¯¥èŠ‚ç‚¹çš„ä½ç½® **æ— å³èŠ‚ç‚¹å€¼** æˆ–è€… **å³èŠ‚ç‚¹å€¼å·²è¢«éå†è¿‡ï¼ˆè¢«åˆ€åˆ‡å¼€äº†ï¼‰** ï¼Œ æ­¤æ—¶å¯ä»¥è®¤ä¸ºï¼Œ **æ­¤èŠ‚ç‚¹ä¸ºæŸä¸ªçˆ¶èŠ‚ç‚¹çš„ å·¦å­èŠ‚ç‚¹**
* å·¦å­èŠ‚ç‚¹çš„æ±‚æ³•ï¼š å½“è§¦å‘`else`æ—¶ï¼Œæˆ‘ä»¬éœ€è¦ç¡®å®šæ’å…¥è¯¥å·¦èŠ‚ç‚¹çš„ **çˆ¶èŠ‚ç‚¹** ã€‚ç”±åå‘å‰åºéå† `å³->æ ¹->å·¦`å’Œåå‘ååºéå†`æ ¹->å³->å·¦`å¯å¾—çŸ¥ï¼š
    * æ ˆä¸­(æŸä¸€ä¸ªèŒƒå›´çš„æ­£å‘ååºéå†)æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å„¿å­éƒ½è¿˜æ²¡æœ‰è¢«éå†è¿‡ï¼Œè¿™äº›èŠ‚ç‚¹çš„é¡ºåºå’Œ **å®ƒä»¬åœ¨åå‘ä¸­åºéå†ä¸­å‡ºç°çš„é¡ºåºä¸€å®šæ˜¯ç›¸åçš„** ã€‚å› æ­¤åªéœ€å’Œæ ˆä¸­çš„`val`å¯¹æ¯”ï¼Œå½“ä¸ç›¸ç­‰äº†ï¼Œåˆ™è¡¨ç¤º`node`ä¸ºè¯¥åšå­å·¦å­èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹(`node`é¢†å…ˆ`s.top`ï¼Œä½†åšæ¯”è¾ƒçš„æ˜¯`s.top()->val`)
        * æŠŠ`->å·¦`å¿½ç•¥ï¼Œè¿™ä¸¤ä¸ªéå†å°±æ˜¯ç›¸åé¡ºåº

* æˆ‘æƒ³ä¸Šé¢çš„è¯æˆ‘è¿‡æ®µæ—¶é—´éƒ½çœ‹ä¸æ‡‚ï¼Œæ‰€ä»¥ç”¨ä¸€ç§ä¹Ÿè®¸å¥½ç†è§£ç‚¹çš„æ–¹æ³•å»è§£é‡Šï¼š
    * å½“èŠ‚ç‚¹Aä¸åŒ¹é…æ—¶ï¼Œå®ƒä¼šæ‰¾å®ƒçš„ **çˆ¶èŠ‚ç‚¹**ã€‚å®ƒçš„çˆ¶èŠ‚ç‚¹åœ¨ **ä¸­åºéå†** åˆ—è¡¨ä¸­ï¼Œå³è¾¹è¡¨ç¤ºå³å­æ ‘èŠ‚ç‚¹ï¼Œå·¦è¾¹è¡¨ç¤ºå·¦å­æ ‘èŠ‚ç‚¹ã€‚
    * å› æ­¤ï¼ŒèŠ‚ç‚¹Aéœ€è¦å›æº¯å¹¶**è·³è¿‡**æ‰€æœ‰åŒåœ¨å³å­æ ‘çš„å…„å¼Ÿå§å¦¹ï¼Œè€Œæ ˆæ­£å¥½è®°å½•äº†å®ƒä»¬ã€‚
    * å½“èŠ‚ç‚¹Aå›æº¯åˆ°ä¸€ä¸ªåœ¨ä¸­åºéå†åˆ—è¡¨ä¸­ä¸å…¶ **ä¸ç›¸ç­‰**  çš„èŠ‚ç‚¹æ—¶ï¼Œè¿™ä¸ªèŠ‚ç‚¹åœ¨ä¸­åºéå†åˆ—è¡¨ä¸­æ˜¯ä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œå³è¾¹æ˜¯è¯¥èŠ‚ç‚¹çš„æ‰€æœ‰å³å­æ ‘èŠ‚ç‚¹ã€‚
    * å®é™…ä¸Šï¼Œè¿™ä¸ªèŠ‚ç‚¹æ˜¯èŠ‚ç‚¹Açš„ **çˆ¶èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹** ï¼Œå› ä¸ºæˆ‘ä»¬æ€»æ˜¯éœ€è¦ç”¨ä¸‹ä¸€ä¸ªèŠ‚ç‚¹åˆ¤æ–­å‰ä¸€ä¸ªèŠ‚ç‚¹æ˜¯å¦ä¸ºèŠ‚ç‚¹Açš„çˆ¶èŠ‚ç‚¹ã€‚
    * å› æ­¤ï¼Œä¼šå¤šèµ°ä¸€æ­¥ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†æ–°èŠ‚ç‚¹åˆ›å»ºä¸ºå·¦å­èŠ‚ç‚¹ï¼Œå¹¶å°†å…¶æ¨å…¥æ ˆä¸­ã€‚

#### ä»ä¸­åºä¸å‰åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘
![279152919230370](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage279152919230370.png)
##### é€’å½’
```cpp
    unordered_map<int,int> myMap();
    int preIndex;
    TreeNode* helper (int left,int right , vector<int>& preorder, vector<int>& inorder)
    {
        if(left>right) //èŒƒå›´ä¸å­˜åœ¨äº†
            return nullptr;

        int inorderVal = preorder[preIndex++];
        TreeNode* root = new TreeNode(inorderVal);
        int index = myMap[inorderVal];

        root->left = helper(left,index-1,preorder,inorder);
        root->right = helper(index+1,right,preorder,inorder);

        return root;
    }
    TreeNode *buildTreeA(vector<int> &preorder, vector<int> &inorder)
    {
        preIndex = 0;

        int index=0;
        for(auto& val : inorder) //å°†ä¸­åºåˆ—è¡¨èŠ‚ç‚¹å€¼è½½å…¥å“ˆå¸Œè¡¨
            myMap[val] = index++;

        return helper(0,inorder.size()-1,preorder,inorder);
    }
```

>è§£æ

* å’Œä¸­ååºé€’å½’åŸç†å·®ä¸å¤šï¼Œå‰åºéå†é¡ºåºä¸º: `æ ¹->å·¦->å³`ï¼Œå³æˆ‘ä»¬å¯ä»¥å°†å‰åºéå†ä»å‰é¢å¼€å§‹é€ä¸ªæ‰¾å‡ºä¸ä¸­åºåˆ—è¡¨å¯¹åº”çš„ä½ç½®èŠ‚ç‚¹ï¼Œè¯¥èŠ‚ç‚¹å·¦è¾¹ä¸ºå·¦å­æ ‘ï¼Œå³è¾¹ä¸ºå³å­æ ‘
* ä¸ä¸­ååºé€’å½’ä¸ç›¸åŒçš„æ˜¯ï¼Œæœ¬é€’å½’ä½¿ç”¨äº† **å…ˆleftå†right**ï¼Œå› ä¸ºå‰åºéå†æ˜¯ `å·¦->å³`ï¼Œå› æ­¤éœ€è¦å¯¹åº”ã€‚è€Œååºåå‘éå†æ˜¯ `æ ¹->å³->å·¦`,å› æ­¤ååºæ˜¯å…ˆå³åå·¦

##### è¿­ä»£
```cpp
//è¿­ä»£
    TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder)
    {
        if (preorder.size() == 0)
        {
            return nullptr;
        }
        auto root = new TreeNode(preorder[0]);
        auto s = stack<TreeNode *>();
        s.push(root);
        int inorderIndex = 0;
        for (int i = 1; i < inorder.size(); i++)
        {
            int preorderVal = preorder[i]; // posterorderValæ€»æ˜¯ä¸ºnode->valå‰ä¸€ä¸ªèŠ‚ç‚¹
            auto node = s.top();
            if (node->val != inorder[inorderIndex])
            {
                node->left = new TreeNode(preorderVal);
                s.push(node->left);
            }
            else
            {
                while (!s.empty() && s.top()->val == inorder[inorderIndex])
                {
                    node = s.top(); // nodeä¸ºs.top()çš„çˆ¶èŠ‚ç‚¹
                    s.pop();
                    inorderIndex++;
                }
                node->right = new TreeNode(preorderVal); //
                s.push(node->right);
            }
        }
        return root;
    }
```

>è§£æ

* å’Œä¸­ååºçš„è¿­ä»£åç€æ¥å°±æ˜¯äº†ï¼Œ~~æˆ‘ä¹Ÿä¸å¤ªæ‡‚~~
* ç»™ä½ çœ‹çœ‹å®˜æ–¹è§£é‡Šå§ï¼
* ä¸Šæ–¹æœ‰è‡ªå·±çš„è§£é‡Šï¼Œ~~è™½ç„¶ç‹—å±ä¸é€š~~
![](vx_images/114844219248796.png =500x)

#### å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ
![345432819230371](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage345432819230371.png)

##### å¹¿åº¦ä¼˜å…ˆæœç´¢[BFS]
```cpp
//DFS
    Node *connect(Node *root)
    {
        if(root == nullptr)
            return nullptr;

        queue<Node*> q;
        q.push(root);

        while(!q.empty())
        {
            int len = q.size();
            auto preNode = q.front(); //preNodeåœ¨nodeèŠ‚ç‚¹çš„å·¦è¾¹
            for(int i=1;i<=len;++i)
            {
                auto node = q.front();
                q.pop();
                if(node!=preNode)
                {
                    node->next = preNode;
                    preNode = node;
                }                   
                else
                    preNode->next = nullptr;
                
                if(node->right)  //å…ˆå³éå†å†å·¦éå†
                    q.push(node->right);
                if(node->left)
                    q.push(node->left);
               
            }
        }
        return root;
    }
```
>è§£æ

* æ ¹æ®queueæ¥å»ºç«‹nextæŒ‡é’ˆ

##### åŸåœ°å»ºç«‹
```cpp
    Node *connect(Node *root)
    {
        if (root == nullptr)
        {
            return root;
        }

        // ä»æ ¹èŠ‚ç‚¹å¼€å§‹
        Node *leftmost = root;

        while (leftmost->left != nullptr)
        {

            // éå†è¿™ä¸€å±‚èŠ‚ç‚¹ç»„ç»‡æˆçš„é“¾è¡¨ï¼Œä¸ºä¸‹ä¸€å±‚çš„èŠ‚ç‚¹æ›´æ–° next æŒ‡é’ˆ
            Node *head = leftmost;

            while (head != nullptr)
            {

                // CONNECTION 1
                head->left->next = head->right;

                // CONNECTION 2
                if (head->next != nullptr)
                {
                    head->right->next = head->next->left; //è¿æ¥ä¸åŒçˆ¶èŠ‚ç‚¹çš„ä¸¤ä¸ªç›¸é‚»èŠ‚ç‚¹
                }

                // æŒ‡é’ˆå‘åç§»åŠ¨
                head = head->next;
            }

            // å»ä¸‹ä¸€å±‚çš„æœ€å·¦çš„èŠ‚ç‚¹
            leftmost = leftmost->left;
        }

        return root;
    }
```
>è§£æ

* å½“åŒä¸€ä¸ª **çˆ¶èŠ‚ç‚¹** çš„å·¦å³èŠ‚ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ `head->left->next = head->right`
* å½“ **çˆ¶èŠ‚ç‚¹** ä¸ç›¸åŒçš„ç›¸é‚»èŠ‚ç‚¹ï¼Œå› ä¸ºåœ¨ **ä¸Šä¸€å±‚** å·²ç»å»ºç«‹äº†è¿™ä¸¤ä¸ªçˆ¶èŠ‚ç‚¹çš„ `nextå…³ç³»` ï¼Œ å› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `head->right->next = head->next->left`æ¥è¿æ¥è¿™ä¸¤ä¸ªèŠ‚ç‚¹
<img src="https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage544875019236664.png" alt="544875019236664" style="zoom:50%;" />
#### å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆâ…¡
![386433619248797](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage386433619248797.png)

##### å¹¿åº¦ä¼˜å…ˆæœç´¢[BFS]
```cpp
//BFS
    Node *connect(Node *root)
    {
        if(root == nullptr)
            return nullptr;

        queue<Node*> q;
        q.push(root);

        while(!q.empty())
        {
            int len = q.size();
            auto preNode = q.front(); //preNodeåœ¨nodeèŠ‚ç‚¹çš„å·¦è¾¹
            for(int i=1;i<=len;++i)
            {
                auto node = q.front();
                q.pop();
                if(node!=preNode)
                {
                    node->next = preNode;
                    preNode = node;
                }                   
                else
                    preNode->next = nullptr;
                
                if(node->right)  //å…ˆå³éå†å†å·¦éå†
                    q.push(node->right);
                if(node->left)
                    q.push(node->left);
               
            }
        }
        return root;
    }
```
>è§£æ

* å’Œâ… å®Œå…¨ç›¸åŒï¼Œæ€è·¯ç›¸åŒï¼Œå¹¿åº¦ä¸‡å²ï¼

#### äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ
![276210716230372](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage276210716230372.png)

##### æ·±åº¦ä¼˜å…ˆæœç´¢
```cpp
class Solution
{
public:
    TreeNode* ans;
    bool *dfs(TreeNode* node , TreeNode* p , TreeNode* q)
    {
        if(node==nullptr)
            return false;

        bool lson = dfs(node->left,p,q);
        bool rson = dfs(node->right,p,q);

        if((lson&&rson) || ((node==p||node==q)&&(lson||rson)))
            ans = root;

        return lson || rson || (node==p || node==q);
        
    }
    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q)
    {
        dfs(root,p,q);
        return ans;
    }
};
```

>è§£æ

* `if((lson&&rson) || ((node==p||node==q)&&(lson||rson)))`
    * å½“å‰èŠ‚ç‚¹çš„å·¦å³èŠ‚ç‚¹ **åŒæ—¶** ç¬¦åˆæ¡ä»¶æˆ–è€…ä»»æ„**å·¦å³å­æ ‘çš„**èŠ‚ç‚¹ å’Œ **å½“å‰èŠ‚ç‚¹** ç¬¦åˆæ¡ä»¶
* `return lson || rson || (node==p || node==q);`
    * è‹¥å·¦èŠ‚ç‚¹æˆ–è€…å³èŠ‚ç‚¹æˆ–è€…å½“å‰èŠ‚ç‚¹ç¬¦åˆæ¡ä»¶ï¼Œåˆ™è¿”å› `true`
* å½“æ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„èŠ‚ç‚¹æ—¶ï¼Œå®ƒçš„ **å­æ ‘** éƒ½ä¼šå˜æˆ `true`

##### å“ˆå¸Œè¡¨
```cpp
class Solution
{
public:
    unordered_map<int, TreeNode *> fa;
    unordered_map<int, bool> vis;
    void dfs(TreeNode *root) // å­˜å‚¨å“ˆå¸Œè¡¨ï¼Œfaè¡¨ç¤ºçˆ¶èŠ‚ç‚¹[val-->node],visè¡¨ç¤º
    {
        if (root->left != nullptr)
        {
            fa[root->left->val] = root;
            dfs(root->left);
        }
        if (root->right != nullptr)
        {
            fa[root->right->val] = root;
            dfs(root->right);
        }
    }
    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q)
    {
        fa[root->val] = nullptr; // æ ¹èŠ‚ç‚¹åœ¨hashé‡Œè¡¨ç¤ºnullptr
        dfs(root);

        while (p != nullptr)
        {
            vis[p->val] = true; // æ„ŸæŸ“å­æ ‘
            p = fa[p->val];     // å›åˆ°çˆ¶èŠ‚ç‚¹ï¼Œç›´åˆ°pä¸ºroot
        }
        while (q != nullptr)
        {
            if (vis[q->val]) // å½“å‰èŠ‚ç‚¹ä½äºpçš„æ„ŸæŸ“è·¯å¾„
                return q;
            q = fa[q->val]; // å›åˆ°çˆ¶èŠ‚ç‚¹ï¼Œç›´åˆ°qä¸ºroot
        }
        return nullptr;
    }
};

```
>è§£æ

* æ€è·¯å’Œé€’å½’å¤§è‡´ç›¸åŒï¼Œéƒ½æ˜¯é€šè¿‡ **æ„ŸæŸ“è·¯å¾„** æ¥è¿›è¡Œåˆ¤æ–­
    1. å…ˆå°† **é™¤rootå¤–** çš„æ‰€æœ‰èŠ‚ç‚¹åŠ å…¥`hash`ï¼Œç”¨å®ƒä»¬çš„å€¼å¯¹åº” **çˆ¶èŠ‚ç‚¹**
    2. ä½¿ç”¨pè¿›è¡Œæ„ŸæŸ“è·¯å¾„ã€‚pä¼šé€šè¿‡è°ƒç”¨ `fa-hash`æ¥ä¸æ–­æŠµè¾¾å®ƒçš„çˆ¶èŠ‚ç‚¹ï¼Œå¹¶ä»¤å®ƒä»¬éƒ½ä¸º `true`(rootä¹Ÿä¼šå˜ä¸ºtrue)
    3. ä½¿ç”¨qæ£€æŸ¥æ„ŸæŸ“è·¯å¾„ã€‚è‹¥qå‘ç°å½“å‰çš„èŠ‚ç‚¹æ˜¯ **pæ„ŸæŸ“è¿‡** çš„ï¼Œä»£è¡¨ç€æ­¤æ—¶çš„qæ˜¯åŸæœ¬çš„pã€qçš„ç¥–å…ˆèŠ‚ç‚¹ 
    
#### äºŒå‰æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ–
![497685119248798](https://axuan-picture.oss-cn-guangzhou.aliyuncs.com/D:%5CFiles_Work%5CPicGo%5Cimage497685119248798.png)

##### å¹¿åº¦ä¼˜å…ˆéå†
```cpp
class Codec
{
public:
    // å°†æ•°ç»„è½¬åŒ–ä¸ºå­—ç¬¦ä¸²æ ¼å¼
    // å¹¿åº¦ä¼˜å…ˆéå†

    //tree to string
    string serialize(TreeNode *root)
    {
        if (!root)
        {
            return "";
        }

        string data = "";
        queue<TreeNode *> q;
        q.push(root);

        while (!q.empty())
        {
            int len = q.size();

            for (int i = 1; i <= len; ++i)
            {
                auto node = q.front();
                q.pop();
                if (!node) //è‹¥èŠ‚ç‚¹ä¸ºç©ºï¼Œåˆ™è½¬åºä¸ºnull
                {
                    data += "null,";
                    continue;
                }
                data += to_string(node->val) + ",";
                q.push(node->left);
                q.push(node->right);
            }
        }

        return data;
    }

    //string to tree
    TreeNode *deserialize(string data)
    {
        if (data.empty())
            return nullptr;

        list<string> dataArray;
        string str;

        //å°†å­—ç¬¦ä¸²è½¬åŒ–ä¸ºæ•°ç»„list
        for (auto &ch : data)
        {
            if (ch == ',')
            {
                dataArray.push_back(str);
                str.clear();
            }
            else
            {
                str.push_back(ch);
            }
        }
        if (!str.empty()) // å­˜å‚¨æœ€åçš„å­—ç¬¦ä¸²
        {
            dataArray.push_back(str);
            str.clear();
        }

        //å°†æ•°ç»„è½¬åŒ–ä¸ºäºŒå‰æ ‘ï¼Œå¹¿åº¦ä¼˜å…ˆéå†
        TreeNode *root = new TreeNode(stoi(dataArray.front()));
        dataArray.erase(dataArray.begin()); // åˆ é™¤
        queue<TreeNode *> q;
        q.push(root);

        while (!q.empty() && !dataArray.empty())
        {
            int len = q.size();

            for (int i = 1; i <= len; ++i)
            {
                auto node = q.front();
                q.pop();

                if (dataArray.front() != "null")
                {
                    node->left = new TreeNode(stoi(dataArray.front()));
                    q.push(node->left);
                }
                else
                {
                    node->left = nullptr;
                }
                dataArray.erase(dataArray.begin());

                if (dataArray.front() != "null")
                {
                    node->right = new TreeNode(stoi(dataArray.front()));
                    q.push(node->right);
                }
                else
                {
                    node->right = nullptr;
                }
                if (!dataArray.empty()) // é˜²æ­¢æ•°ç»„è¶Šç•Œ
                    dataArray.erase(dataArray.begin());
            }
        }

        return root;
    }
};

```
>è§£æ

* ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆéå†è¿›è¡Œè½¬åº
    * è‹¥å½“å‰èŠ‚ç‚¹ **ä¸ä¸ºç©º** ï¼Œ åˆ™`data += to_string(node->val) + ",";`
    * è‹¥å½“å‰èŠ‚ç‚¹ **ç©º** ï¼Œ åˆ™`data += "null,";`ï¼Œå¹¶è·³è¿‡ååºçš„èŠ‚ç‚¹æ¨å…¥
*  ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆéå†è¿›è¡Œåè½¬åº
    * å…ˆå°†`data`ä¸­é€—å·ä¸é€—å·ä¹‹é—´çš„å…ƒç´ å­˜å…¥`list`
        * æ³¨æ„ï¼Œä¹ æƒ¯æ€§é—®é¢˜ï¼šè‹¥`data`å°¾å·´æ²¡æœ‰é€—å·ï¼Œåˆ™éœ€è¦è¿›å…¥`if (!str.empty())`è¿›è¡Œé¢å¤–èµ‹å€¼ï¼Œè™½ç„¶è¿™é¢˜å°¾å·´å­˜åœ¨é€—å·
    * å½“`list`çš„é¦–ä¸ªå…ƒç´ ä¸ä¸º`null`æ—¶ï¼Œåˆ›å»ºèŠ‚ç‚¹å¹¶ **ä¾æ¬¡** èµ‹å€¼ç»™`node->left ã€node->right`ï¼ŒåŒæ—¶ï¼Œåˆ é™¤`list`çš„é¦–ä¸ªå…ƒç´ ï¼›
    * è‹¥`list`å…ƒç´ ä¸º`nullptr`ï¼Œåˆ™æŒ‡å‘`nullptr`

##### æ·±åº¦ä¼˜å…ˆéå†
```cpp
class Codec
{
public:
    // tree to data
    string serialize(TreeNode *root) //main
    {
        string ret;
        rserialize(root, ret);
        return ret;
    }
    void rserialize(TreeNode *root, string &str)
    {
        if (root == nullptr)
        {
            str += "None,";
        }
        else
        {
            str += to_string(root->val) + ",";
            rserialize(root->left, str);
            rserialize(root->right, str);
        }
    }

    // data to tree
    TreeNode *deserialize(string data)  //main
    {
        //å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºlist
        list<string> dataArray;
        string str;
        for (auto &ch : data)
        {
            if (ch == ',')
            {
                dataArray.push_back(str);
                str.clear();
            }
            else
            {
                str.push_back(ch);
            }
        }
        if (!str.empty())
        {
            dataArray.push_back(str);
            str.clear();
        }
        //å°†listè½¬æ¢ä¸ºæ ‘
        return rdeserialize(dataArray);
    }
    TreeNode *rdeserialize(list<string> &dataArray)
    {
        if (dataArray.front() == "None")
        {
            dataArray.erase(dataArray.begin());
            return nullptr;
        }

        TreeNode *root = new TreeNode(stoi(dataArray.front()));
        dataArray.erase(dataArray.begin());
        root->left = rdeserialize(dataArray);
        root->right = rdeserialize(dataArray);
        return root;
    }
};

```
>è§£æ

* ä½¿ç”¨é€’å½’çš„æ–¹å¼è½¬åºï¼Œå†ä½¿ç”¨é€’å½’çš„æ–¹å¼åè½¬åºï¼ŒåŸç†å’Œå¹¿åº¦éå†è½¬åºä¸€æ ·