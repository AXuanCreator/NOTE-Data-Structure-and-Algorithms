<style>
pre {
  overflow-y: auto;
  max-height: 500px;
}
</style>
**æœ¬ç¬”è®°ç”±ä¼Ÿå¤§çš„çˆ±ç©<mark>åŸç¥</mark>çš„å¾æ•™æˆæ’°å†™ï¼Œå”®ä»·~~ï¿¥209~~ï¿¥99**
**çœ‹åŸç¥ï¼Œç©åŸç¥ï¼Œçˆ±åŸç¥ï¼ŒåŸç¥ä¸‡å²ğŸ˜Š**
![æˆ‘çš„çˆ±è‰ğŸ¥µ](vx_images/536023321236635.png =300x)
# é“¾è¡¨


## å•é“¾è¡¨

### ---------------------

 #### åˆ›å»ºé“¾è¡¨æ¨¡æ¿
```c
typedef struct Node
{
    int val;
    struct Node *next;
}MyLinkList;
```
> MyLinkListæ˜¯ç»“æ„çš„åˆ«åï¼Œ`int val`å¯æ›¿æ¢ä¸ºä»»æ„ç±»å‹

#### åˆ›å»ºå¤´èŠ‚ç‚¹
```c
MyLinkedList* listHeadCreat()
{
    MyLinkedList *list_head = (MyLinkedList*)malloc(sizeof(MyLinkedList));  //é“¾è¡¨å¤´å†…å­˜åˆ†é…
    /*åˆå§‹åŒ–é“¾è¡¨å¤´ï¼Œæ­¤æ—¶valå€¼å¯ä¸ºä»»æ„*/
    list_head->val=0;
    list_head->next=NULL;//nextä¸ºNULLï¼ŒåæœŸåŠ å…¥æˆ–åˆ é™¤èŠ‚ç‚¹

    return list_head;  //è¿”å›é“¾è¡¨å¤´
}
```
>é“¾è¡¨å¤´`list_head`å¯ä¸º<mark>ä¸´æ—¶é“¾è¡¨å¤´</mark>ï¼ŒåæœŸå¯è½½å…¥å…¶ä»–é“¾è¡¨å¤´

#### è½½å…¥é¦–ä½èŠ‚ç‚¹
```c
void listAddHead(MyLinkedList *list_head,int val)
{
    MyLinkedList *node = (MyLinkedList*)malloc(sizeof(MyLinkedList));  //nodeä¸ºç»“ç‚¹ï¼Œåˆå§‹åŒ–èŠ‚ç‚¹

    node->val=10;
    node->next=NULL; //æ— è®ºå¦‚ä½•ï¼Œnextéƒ½éœ€å…ˆåˆå§‹åŒ–ä¸ºNULL

    /*è‹¥é“¾è¡¨æœ¬èº«ä¸ºç©º*/
    if(list_head->next == NULL){  
        list_head->next = node;  //next = nodeï¼Œè®©nextæŒ‡å‘nodeæ‰€æŒ‡å‘çš„é“¾è¡¨
        return;
    }
    /*è‹¥é“¾è¡¨å¤´è¿æ¥ç€å…¶ä»–é“¾è¡¨*/
    else{
        node->next=list_head->next;   //å°†åŸé“¾è¡¨æŒ‚åœ¨æ–°ç»“èŠ‚ç‚¹åé¢
        list_head->next=node;         //å†å°†é“¾è¡¨å¤´ä¸æ–°é“¾è¡¨è¿æ¥
    }
}

```
:::alert-info
è§£æ`list_head->next = node`
[`list_head->next`]æ˜¯ä¸€ä¸ª**MyLinkedList**ç±»å‹çš„æŒ‡é’ˆï¼Œå®ƒæŒ‡å‘**MyLinkedList**è¿™ä¸€ç»“æ„ï¼Œè€Œ`node`åŒæ ·æ˜¯**MyLinkedList**çš„æŒ‡é’ˆï¼Œå› æ­¤å«ä¹‰ä¸º**å°†`nextæŒ‡é’ˆ`æŒ‡å‘nodeæ‰€æŒ‡å‘çš„ç»“æ„**
:::

#### è½½å…¥æœ«å°¾èŠ‚ç‚¹
```c
void listAddTail(MyLinkedList *list_head, int val)
{
    /*æ–°å»ºèŠ‚ç‚¹*/
    MyLinkedList *node = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    node->val = val;
    node->next = NULL;

    /*åˆ›å»ºä¸´æ—¶ç§»åŠ¨å‹é“¾è¡¨å¤´*/
    MyLinkedList *list_move = list_head; //æ­¤æ—¶list_moveä¸ºä¸´æ—¶é“¾è¡¨å¤´ï¼Œç”¨äºä¸‹é¢çš„å¾ªç¯

    /*å¼€å§‹ç§»åŠ¨*/
    while (list_move->next != NULL)  
    {
        list_move = list_move->next;
    }

    /*è½½å…¥é“¾è¡¨å°¾*/
    list_move->next=node;
}
```
:::alert-info
è§£æ`while (list_move->next != NULL)  
    {
        list_move = list_move->next;
    }`
    è®¾èŠ‚ç‚¹ä¸º1->2->3,åœ¨`list_move`å¤„äºèŠ‚ç‚¹2æ—¶ï¼Œè¯­å¥`list_move=list_move->next`ä¼šä½¿å…¶ç§»åŠ¨è‡³èŠ‚ç‚¹3ï¼Œè€Œ**èŠ‚ç‚¹3->nextä¸ºNULL**ï¼Œå› æ­¤åœ¨whileåˆ¤æ–­æ—¶æŒ‡å‘NULLï¼Œé€€å‡ºå¾ªç¯
::::
>`while(list_move->next != NULL)`ä¼šåœåœ¨æœ€åä¸€ä¸ªèŠ‚ç‚¹
>`while(list_move != NULL)`ä¼šåœåœ¨æœ€åä¸€ä¸ªèŠ‚ç‚¹ä¹‹å

#### å¯»æ‰¾ä»»æ„èŠ‚ç‚¹ä¿¡æ¯
```c
void listGet(MyLinkedList *list_head, int index)
{
    /*åˆ¤æ–­indexæ˜¯å¦åˆæ³•*/
    if (index < 0 || list_head->next == NULL)
        return -1;

    /*æ–°å»ºé¦–ä½ç§»åŠ¨èŠ‚ç‚¹*/
    int now = 0;
    MyLinkedList *list_move = list_head->next; //é¦–ä½èŠ‚ç‚¹ä»0å¼€å§‹

    /*ç§»åŠ¨èŠ‚ç‚¹*/
    while (now < index)
    {
        if (list_move == NULL)
        {
            return -1;
        }
        list_move = list_move->next;
        now++;
    }
    if (list_move != NULL)
        return list_move->val;

    return -1;
}
```
:::alert-info
ä¸ºä½•éœ€è¦`if (list_move != NULL)`
1.å½“**index=0**æ—¶ï¼Œæ— æ³•è¿›å…¥å¾ªç¯ï¼Œæ­¤æ—¶ç›´æ¥è¿”å›å¯¹åº”çš„å€¼
2.å½“**index=é“¾è¡¨é•¿åº¦+1**æ—¶ï¼Œnow=indexæ—¶ï¼Œ`list_move=NULL`
:::
>return -1ä»£è¡¨æ— æ­¤èŠ‚ç‚¹

**whileå¾ªç¯è¿˜æœ‰ç¬¬äºŒç§å†™æ³•ï¼Œæ­¤æ—¶<mark>ä¸éœ€è¦åˆ¤æ–­è¯­å¥</mark>**
```c
/*ç§»åŠ¨èŠ‚ç‚¹*/
while (list_move != NULL)
    {
        if(now==index)
            return list_move->val;
        
        list_move=list_move->next;
        now++;
    }
    
    return -1;
```
>è‹¥`list_move == NULL`ï¼Œå³ä»£è¡¨indexè¶…å‡ºé“¾è¡¨é•¿åº¦
>å½“`index=0`æ—¶ï¼Œä»ç„¶å¯ä»¥è¿›å…¥å¾ªç¯

#### ä»»æ„ä½ç½®è½½å…¥èŠ‚ç‚¹
```c
int listAddIndex(MyLinkedList *list_head , int index,int val)
{
    /*åˆ¤æ–­indexæ˜¯å¦ä¸ºéæ­£æ•°ï¼Œè‹¥æ˜¯ï¼Œåˆ™å®ç°é¦–ä½æ’å…¥*/
    if(index<=0)
        listAddHead(list_head,val);

    /*æ–°å»ºå¾…æ’å…¥èŠ‚ç‚¹*/
    MyLinkedList *node = (MyLinkedList*)malloc(sizeof(MyLinkedList));
    node->val=val;
    node->next=NULL;

    /*æ–°å»ºé¦–ä½ç§»åŠ¨èŠ‚ç‚¹*/
    MyLinkedList *list_move = list_head->next;
    int now=0;

    /*æ’å…¥*/
    while(list_move->next!=NULL)
    {
        if(now==index-1)
            break;  //éœ€åœ¨indexå‰1ä½åœæ­¢å¾ªç¯ï¼Œæ­¤æ—¶èŠ‚ç‚¹ä¸ºindex-1å·
        
        list_move=list_move->next;
        now++;
    }

    /*åˆ¤æ–­nowæ˜¯å¦åˆæ³•*/
    if(now!=index-1)
        return; 

    /*èŠ‚ç‚¹è½½å…¥*/
    node->next=list_move->next;
    list_move->next=node;
    
}
```
:::alert-info
è§£æ`if(now!=index-1) {return;}`
å½“æ¡ä»¶ä¸ºTRUEæ—¶ï¼Œå³`list_move->next==NULL`ï¼Œæ­¤æ—¶ç§»åŠ¨èŠ‚ç‚¹ä½äºé“¾è¡¨çš„**æœ€åä¸€ä¸ªèŠ‚ç‚¹**ï¼Œè€Œnowä¸index-1çš„å…³ç³»æœªçŸ¥ï¼Œæ— æ³•è½½å…¥ã€‚è¿™ç§æƒ…å†µçš„å‡ºç°ä¸€èˆ¬æ˜¯*indexè¶…å‡ºé“¾è¡¨é•¿åº¦*
:::
>é“¾è¡¨ç´¢å¼•ä¸€èˆ¬ä»0å¼€å§‹è®¡ç®—
>å½“èŠ‚ç‚¹éœ€è¦æ’å…¥3å·èŠ‚ç‚¹æ—¶ï¼Œ**åŸ3å·èŠ‚ç‚¹**éœ€å‘åç§»åŠ¨ï¼Œå˜æˆ4å·èŠ‚ç‚¹(å³`list_move->next`)ã€‚æ­¤æ—¶`node->next`æŒ‡å‘`list_move->next`ï¼Œè€Œ`list_move->next`ï¼ˆæ­¤æ—¶ä»£è¡¨**äºŒå·èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹**ï¼‰æŒ‡å‘node

#### ä»»æ„ä½ç½®åˆ é™¤èŠ‚ç‚¹
```c
void listDelIndex(MyLinkedList *list_head, int index)
{
    /*åˆ¤æ–­indexçŠ¶æ€*/
    if (index < 0 || list_head->next == NULL)
        return;

    if (index == 0)
    { //å½“ä¸ºé¦–ä½èŠ‚ç‚¹æ—¶ï¼Œç›´æ¥åˆ é™¤å³å¯(headä¸å­˜å‚¨æ•°æ®)
        list_head->next = list_head->next->next;
        return;
    }

    /*æ–°å»ºé¦–ä½ç§»åŠ¨èŠ‚ç‚¹*/
    MyLinkedList *list_move = list_head->next;
    int now = 0;

    /*èŠ‚ç‚¹åˆ é™¤*/
    while (list_move->next != NULL)
    {
        if (now == index - 1)
            break;

        list_move = list_move->next;
        now++;
    }

    /*åˆ¤æ–­*/
    if (list_move->next != NULL && now == index - 1)
        list_move->next = list_move->next->next;
}
```
:::alert-info
è§£æ`if (list_move->next != NULL && now == index - 1)`
é€€å‡ºå¾ªç¯æœ‰ä¸¤ç§æƒ…å†µï¼š
â‘ æ­£å¸¸é€€å‡ºï¼šnow=index-1
â‘¡é—®é¢˜é€€å‡ºï¼š`list_move->next == NULL`,æ­¤æ—¶ä¸æ¸…æ¥š**nowä¸index-1**çš„å…³ç³»ï¼Œè‹¥ä¸¤è€…ä¸ç›¸ç­‰ï¼Œåˆ™indexè¶…å‡ºé“¾è¡¨é•¿åº¦ã€‚
:::
:::alert-danger
æ³¨æ„ï¼Œæ— æ³•é€šè¿‡æ­¤å‡½æ•°åˆ é™¤å°¾èŠ‚ç‚¹
è®¾å°¾èŠ‚ç‚¹ä¸º5ï¼Œå½“`list_move`å¤„äº5ï¼ˆ`now=5`ï¼‰æ—¶ï¼Œ**å¾ªç¯é€šè¿‡whileé€€å‡º**ã€‚è€Œindexä¹Ÿä¸º5ï¼Œå› æ­¤æ— æ³•åˆ é™¤
:::


#### èŠ‚ç‚¹æ‰“å°
```c
void listPrintf(MyLinkedList *list_head , int len)
{
    /*åˆ›å»ºç§»åŠ¨èŠ‚ç‚¹*/
    MyLinkedList *list_move = list_head->next;

    for(int i=0;i<len;i++)
    {
        printf("%d",list_move->val);
        list_move=list_move->next;
    }
}
```
#### å†…å­˜é‡Šæ”¾
```c
void listNodeFree(MyLinkedList *node)
{
    if(node->next!=NULL)
    {
        listNodeFree(node->next);
        node->next=NULL;
    }
    free(node);  
}

void listFree(MyLinkedList *list_head)
{
    listNodeFree(list_head);
}
```
>`node->next=NULL`æ˜¯ä¸ºäº†é¿å…æŒ‡å‘é”™è¯¯ï¼Œå› ä¸ºæ­¤æ—¶çš„`node->next`å·²ç»**free**

#### å®Œæ•´å®ç°
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node 
{
    int val;
    struct Node *next;
} MyLinkedList;

/*åˆ›å»ºé“¾è¡¨*/
MyLinkedList* listHeadCreat()
{
    MyLinkedList *list_head = (MyLinkedList *)malloc(sizeof(MyLinkedList)); //é“¾è¡¨å¤´å†…å­˜åˆ†é…
    /*åˆå§‹åŒ–é“¾è¡¨å¤´ï¼Œæ­¤æ—¶valå€¼å¯ä¸ºä»»æ„*/
    list_head->val = 0;
    list_head->next = NULL; // nextä¸ºNULLï¼ŒåæœŸåŠ å…¥æˆ–åˆ é™¤ç»“ç‚¹

    return list_head; //è¿”å›é“¾è¡¨å¤´
}

/*è½½å…¥é“¾è¡¨å¤´*/
void listAddHead(MyLinkedList *list_head, int val)
{
    MyLinkedList *node = (MyLinkedList *)malloc(sizeof(MyLinkedList)); // nodeä¸ºç»“ç‚¹ï¼Œåˆå§‹åŒ–ç»“ç‚¹

    node->val = val;
    node->next = NULL; //æ— è®ºå¦‚ä½•ï¼Œnextéƒ½éœ€å…ˆåˆå§‹åŒ–ä¸ºNULL

    /*è‹¥é“¾è¡¨æœ¬èº«ä¸ºç©º*/
    if (list_head->next == NULL)
    {
        list_head->next = node; // next = nodeï¼Œè®©nextæŒ‡å‘nodeæ‰€æŒ‡å‘çš„é“¾è¡¨
        return;
    }
    /*è‹¥é“¾è¡¨å¤´è¿æ¥ç€å…¶ä»–é“¾è¡¨*/
    else
    {
        node->next = list_head->next; //å°†åŸé“¾è¡¨æŒ‚åœ¨æ–°ç»“ç‚¹åé¢
        list_head->next = node;       //å†å°†é“¾è¡¨å¤´ä¸æ–°é“¾è¡¨è¿æ¥
    }
}

/*è½½å…¥é“¾è¡¨å°¾*/
void listAddTail(MyLinkedList *list_head, int val)
{
    /*æ–°å»ºèŠ‚ç‚¹*/
    MyLinkedList *node = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    node->val = val;
    node->next = NULL;

    /*åˆ›å»ºä¸´æ—¶ç§»åŠ¨å‹é“¾è¡¨å¤´*/
    MyLinkedList *list_move = list_head; //æ­¤æ—¶list_moveä¸ºä¸´æ—¶é“¾è¡¨å¤´ï¼Œç”¨äºä¸‹é¢çš„å¾ªç¯

    /*å¼€å§‹ç§»åŠ¨*/
    while (list_move->next != NULL)
    {
        list_move = list_move->next;
    }

    /*è½½å…¥é“¾è¡¨å°¾*/
    list_move->next = node;
}

/*å¯»æ‰¾ä»»æ„èŠ‚ç‚¹ä¿¡æ¯*/
int listGet(MyLinkedList *list_head, int index)
{
    /*åˆ¤æ–­indexæ˜¯å¦åˆæ³•*/
    if (index < 0 || list_head->next == NULL)
        return (-1);

    /*æ–°å»ºé¦–ä½ç§»åŠ¨èŠ‚ç‚¹*/
    int now = 0;
    MyLinkedList *list_move = list_head->next; //é¦–ä½èŠ‚ç‚¹ä»0å¼€å§‹

    /*ç§»åŠ¨èŠ‚ç‚¹*/
    /*while (now < index)
    {
        if (list_move == NULL)
        {
            return -1;
        }
        list_move = list_move->next;
        now++;
    }
    if (list_move != NULL)
        return list_move->val;*/

    while (list_move != NULL)
    {
        if (now == index)
            return list_move->val;

        list_move = list_move->next;
        now++;
    }

    return -1;
}

/*ä»»æ„ä½ç½®æ’å…¥èŠ‚ç‚¹*/
void listAddIndex(MyLinkedList *list_head, int index, int val)
{
    /*åˆ¤æ–­indexæ˜¯å¦ä¸ºéæ­£æ•°ï¼Œè‹¥æ˜¯ï¼Œåˆ™å®ç°é¦–ä½æ’å…¥*/
    if (index <= 0)
        listAddHead(list_head, val);

    /*æ–°å»ºå¾…æ’å…¥èŠ‚ç‚¹*/
    MyLinkedList *node = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    node->val = val;
    node->next = NULL;

    /*æ–°å»ºé¦–ä½ç§»åŠ¨èŠ‚ç‚¹*/
    MyLinkedList *list_move = list_head->next;
    int now = 0;

    /*æ’å…¥*/
    while (list_move->next != NULL)
    {
        if (now == index - 1)
            break; //éœ€åœ¨indexå‰1ä½åœæ­¢å¾ªç¯ï¼Œæ­¤æ—¶èŠ‚ç‚¹ä¸ºindex-1å·

        list_move = list_move->next;
        now++;
    }

    /*åˆ¤æ–­nowæ˜¯å¦åˆæ³•*/
    if (now != index - 1)
        return;

    /*èŠ‚ç‚¹è½½å…¥*/
    node->next = list_move->next;
    list_move->next = node;
}

/*ä»»æ„ä½ç½®åˆ é™¤èŠ‚ç‚¹*/
void listDelIndex(MyLinkedList *list_head, int index)
{
    /*åˆ¤æ–­indexçŠ¶æ€*/
    if (index < 0 || list_head->next == NULL)
        return;

    if (index == 0)
    { //å½“ä¸ºé¦–ä½èŠ‚ç‚¹æ—¶ï¼Œç›´æ¥åˆ é™¤å³å¯
        list_head->next = list_head->next->next;
        return;
    }

    /*æ–°å»ºé¦–ä½ç§»åŠ¨èŠ‚ç‚¹*/
    MyLinkedList *list_move = list_head->next;
    int now = 0;

    /*èŠ‚ç‚¹åˆ é™¤*/
    while (list_move->next != NULL)
    {
        if (now == index - 1)
            break;

        list_move = list_move->next;
        now++;
    }

    /*åˆ¤æ–­*/
    if (list_move->next != NULL && now == index - 1)
        list_move->next = list_move->next->next;
    
}

/*å†…å­˜é‡Šæ”¾*/
void listNodeFree(MyLinkedList *node)
{
    if(node->next!=NULL)
    {
        listNodeFree(node->next);
        node->next=NULL;
    }
    free(node);  
}

void listFree(MyLinkedList *list_head)
{
    listNodeFree(list_head);
}

/*èŠ‚ç‚¹æ‰“å°*/
void listPrintf(MyLinkedList *list_head , int len)
{
    /*åˆ›å»ºç§»åŠ¨èŠ‚ç‚¹*/
    MyLinkedList *list_move = list_head->next;

    for(int i=0;i<len;i++)
    {
        printf("%d",list_move->val);
        list_move=list_move->next;
    }
}
int main()
{
    MyLinkedList *list_head = listHeadCreat();

    listAddHead(list_head,1);
    listAddIndex(list_head,1,2);
    listAddIndex(list_head,2,3);
    listAddTail(list_head,4);
    listDelIndex(list_head,2);
    listPrintf(list_head,3);
    listFree(list_head);

    system("pause");
}

```
#### éœ€è¦æ³¨æ„çš„ç‚¹
>1. åœ¨è°ƒç”¨ next å­—æ®µä¹‹å‰ï¼Œå§‹ç»ˆæ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦ä¸ºç©ºã€‚
>2. ä»”ç»†å®šä¹‰å¾ªç¯çš„ç»“æŸæ¡ä»¶

#### å°é¢˜
##### åˆ é™¤å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹
**ç¤ºæ„å›¾**
![](vx_images/549773013230260.png)
###### é•¿åº¦æ³•
```c
/*åˆ é™¤å€’æ•°ç¬¬nä¸ªèŠ‚ç‚¹ï¼ˆé•¿åº¦æ³•ï¼‰ã€headã€‘å­˜å‚¨æ•°æ®*/
struct MyLinkedList *removeListFromEnd(struct MyLinkedList *head, int n)
{
    // åˆå§‹åŒ–èŠ‚ç‚¹
    MyLinkedList *list_move = head;

    // é•¿åº¦è®¡ç®—
    int len = 0;
    int new = 0;
    while (list_move != NULL)
    {
        len++;
        list_move = list_move->next;
    }
    list_move = head;
    int new_len = len - n;

    // å®šä½è‡³å¾…åˆ é™¤èŠ‚ç‚¹çš„å‰ä¸€ä½
    while (list_move != NULL && new < new_len)
    {
        if (new == new_len - 1)
            break;
        list_move = list_move->next;
        new ++;
    }

    // åˆ é™¤èŠ‚ç‚¹åˆ¤æ–­
    if (list_move->next != NULL && new_len != 0)
        list_move->next = list_move->next->next;
    if (new_len == 0)
    {
        head = list_move->next;
    }

    return head;
}
```
###### åŒæŒ‡é’ˆæ³•
```c
/*åˆ é™¤ç¬¬Nä¸ªèŠ‚ç‚¹ï¼ˆåŒæŒ‡é’ˆæ³•ï¼‰ã€headå­˜å‚¨æ•°æ®ã€‘*/
struct Node* removeNthFromEnd(MyLinkedList* head, int n){
    //åŒæŒ‡é’ˆå£°æ˜
    MyLinkedList* list_slow;
    MyLinkedList* list_fast;

    //å¿«æŒ‡é’ˆå‰è¿›Nä½
    list_slow = head;
    list_fast = head;
    for(int i=0;i<n;i++){
        if(list_fast->next == NULL)
        {
            list_fast=NULL;
            break;
        }
        list_fast=list_fast->next;
    } 
    
    //å¿«æ…¢æŒ‡é’ˆåŒæ—¶å‰è¿›
    while(list_fast!=NULL && list_fast->next!=NULL)
    {
        list_fast=list_fast->next;
        list_slow=list_slow->next;
    }
    
    //åˆ¤æ–­
    if(list_fast==NULL)
        head=head->next;
    else
        list_slow->next=list_slow->next->next;
        
    return head;
}
```
:::alert-info
è§£æ`if(list_fast->next == NULL)
        {
            list_fast=NULL;
            break;
        }`
å½“**é“¾è¡¨é•¿åº¦-Nä¸º0æ—¶**ï¼Œ`list_fast`ä¼šæº¢å‡ºï¼Œæ­¤æ—¶éœ€æ‰‹åŠ¨è®¾ç½®`list_fast`ä¸º`NULL`
:::
##### åˆ é™¤é“¾è¡¨æŒ‡å®šæ•°æ®
**ç¤ºæ„å›¾**
![](vx_images/183901515230263.png)
###### åŒæŒ‡é’ˆæ³•ï¼ˆè™šæ‹Ÿå¤´é“¾è¡¨ï¼‰
```c
/*åˆ é™¤é“¾è¡¨æŒ‡å®šå…ƒç´ */
struct Node *removeElements(MyLinkedList *head, int val)
{
    if (head == NULL)  //åˆ¤æ–­æ˜¯å¦ä¸ºç©ºé“¾è¡¨
        return head;

    MyLinkedList *pre_head = (MyLinkedList *)malloc(sizeof(MyLinkedList));  //è™šæ‹Ÿé“¾è¡¨å¤´
    pre_head->next = head;
    MyLinkedList *pre = pre_head;  //å‰æŒ‡é’ˆ
    MyLinkedList *cur = head;      //åæŒ‡é’ˆ

    //ä»çœŸå®å¤´é“¾è¡¨å¼€å§‹åˆ¤æ–­
    while (cur != NULL)
    {
        if (cur->val == val)  
        {
            pre->next = cur->next;  //åˆ é™¤æ“ä½œ 
            cur = cur->next;
        }
        else 
        {
            pre = cur;  //æŒ‡é’ˆé‡ç½®äºéVALé“¾è¡¨å¤„
            cur = cur->next;
        }
    }

    return pre_head->next;
}

```
:::alert-i
â‘ è™šæ‹Ÿå¤´é“¾è¡¨`pre_head`æŒ‡å‘`head`ï¼Œå› æ­¤åœ¨åˆ¤æ–­æ—¶å¯ä»¥åšåˆ°**ç›´æ¥åˆ é™¤ç¬¦åˆæ¡ä»¶çš„å¤´é“¾è¡¨**
â‘¡`pre`æŒ‡é’ˆä¼šåœ¨**ä¸`val`ä¸ç›¸ç­‰çš„èŠ‚ç‚¹å¤„é‡ç½®**
â‘¢`return pre_head->next`æ‰æ˜¯è¿”å›çœŸæ­£çš„å¤´é“¾è¡¨æŒ‡é’ˆï¼Œ**`pre_head`**æ°¸è¿œæ˜¯è™šæ‹Ÿå¤´é“¾è¡¨
:::
###### é€’å½’æ³•
```c
/*åˆ é™¤é“¾è¡¨æŒ‡å®šå…ƒç´ --é€’å½’*/
struct Node* removeElements(MyLinkedList* head, int val) {
    if (head == NULL) {
        return head;
    }
    head->next = removeElements(head->next, val);
    return head->val == val ? head->next : head;
}
```
:::alert-d
æ³¨æ„:
**å¤´èŠ‚ç‚¹çš„åˆ é™¤**å·²åœ¨`return head->val == val ? head->next : head;`ä¸­å®Œæˆï¼Œå¦‚æœ`head->val == val`ï¼Œä¼šè¿”å›ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
:::
>å½“èŠ‚ç‚¹æ•°é‡å¤šæ—¶ï¼Œ**è¯·å‹¿ä½¿ç”¨é€’å½’**ï¼Œä¼šå¯¼è‡´æ ˆæ»¡
##### å¥‡å¶é“¾è¡¨
```
é¢˜ç›®è¦æ±‚ï¼š
ç»™å®šå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head ï¼Œå°†æ‰€æœ‰ç´¢å¼•ä¸ºå¥‡æ•°çš„èŠ‚ç‚¹å’Œç´¢å¼•ä¸ºå¶æ•°çš„èŠ‚ç‚¹åˆ†åˆ«ç»„åˆåœ¨ä¸€èµ·ï¼Œç„¶åè¿”å›é‡æ–°æ’åºçš„åˆ—è¡¨ã€‚
ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„ç´¢å¼•è¢«è®¤ä¸ºæ˜¯ å¥‡æ•° ï¼Œ ç¬¬äºŒä¸ªèŠ‚ç‚¹çš„ç´¢å¼•ä¸º å¶æ•° ï¼Œä»¥æ­¤ç±»æ¨ã€‚
è¯·æ³¨æ„ï¼Œå¶æ•°ç»„å’Œå¥‡æ•°ç»„å†…éƒ¨çš„ç›¸å¯¹é¡ºåºåº”è¯¥ä¸è¾“å…¥æ—¶ä¿æŒä¸€è‡´ã€‚
ä½ å¿…é¡»åœ¨ O(1) çš„é¢å¤–ç©ºé—´å¤æ‚åº¦å’Œ O(n) çš„æ—¶é—´å¤æ‚åº¦ä¸‹è§£å†³è¿™ä¸ªé—®é¢˜ã€‚
```
**ç¤ºæ„å›¾**
![](vx_images/420493919230263.png)

###### åˆ†ç¦»èŠ‚ç‚¹ååˆå¹¶
```c
struct ListNode* oddEvenList(struct ListNode* head)
{
    if(head==NULL)
        return head;
    
    struct ListNode* evenhead = head->next;  //åˆ›å»ºå¶ç´¢å¼•é“¾è¡¨å¤´æŒ‡é’ˆ
    struct ListNode* even = evenhead;
    struct ListNode* odd = head;

    while(even!=NULL && even->next!=NULL)
    {
        odd->next=even->next;
        odd=odd->next;
        even->next=odd->next;
        even=even->next;     
    }
    odd->next=evenhead;

    return head;
}
```
:::alert-info
`while(even!=NULL && even->next!=NULL)`ä¸ºä½•ä¸èƒ½å†™æˆ`while(even!=NULL || even->next!=NULL)`
å½“`even!=NULL`è€Œ`even->next==NULL`æ—¶ï¼Œç”¨ç¬¬äºŒç§å†™æ³•ä¼šå‘ç”ŸæŠ¥é”™
:::
##### åè½¬é“¾è¡¨
**ç¤ºæ„å›¾**
![](vx_images/138054809230261.png)

###### è¿­ä»£æ³•/åŒæŒ‡é’ˆæ³•
```c
/*åè½¬é“¾è¡¨-è¿­ä»£*/
struct Node* reverseList(MyLinkedList* head){ 
    MyLinkedList* pre=NULL;  //å‰ä¸€ä½
    MyLinkedList* cur=head;  //åä¸€ä½

    while(cur!=NULL)
    {
        MyLinkedList* temp = cur->next; //å­˜å‚¨curåä¸€ä½èŠ‚ç‚¹
        cur->next = pre;  //è®©curçš„åä¸€ä½æŒ‡å‘å‰ä¸€ä½
        pre = cur;
        cur = temp;
    }

    return pre;
}
```
###### é€’å½’æ³•
```c
/*åè½¬é“¾è¡¨-é€’å½’*/
struct Node* reverseList(MyLinkedList* head){
    if (head==NULL || head->next == NULL)
        return head;

    MyLinkedList* Newhead = reverseList(head->next);   //æœ€åä¸€ä½ï¼Œä¹Ÿæ˜¯æ–°é“¾è¡¨çš„å¤´éƒ¨
    
    head->next->next = head;  //ä»¤headçš„åä¸€ä½èŠ‚ç‚¹æŒ‡å‘head
    head->next = NULL;  //ä»¤headæŒ‡å‘NULL ï¼ˆå› ä¸ºheadä¸åä¸€ä½æŒ‡å‘æ–¹å‘å·²åè½¬ï¼Œheadæ— æŒ‡å‘èŠ‚ç‚¹)
    
    return Newhead;
}
```
:::alert-info
å®šä¹‰`Newhead`çš„å…³é”®è¯­å¥æ˜¯`return head`ï¼Œåé¢çš„`return Newhead`å®é™…ä¸Šæ˜¯ä¸æ–­è¿”å›æœ¬èº«
`head->next->next=head`æ„ä¹‰æ˜¯**è®©headçš„åä¸€ä½æŒ‡å‘head**ï¼Œè€Œæ­¤æ—¶headä¸å†å…·æœ‰æŒ‡å‘åä¸€ä½çš„åŠŸèƒ½ï¼Œå› æ­¤`head->next=NULL`
:::
>`return Newhead`è¿”å›ä¸€ä¸ªåè½¬é“¾è¡¨
##### å›æ–‡é“¾è¡¨
**é¢˜ç›®è¦æ±‚**
```
ç»™ä½ ä¸€ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head ï¼Œè¯·ä½ åˆ¤æ–­è¯¥é“¾è¡¨æ˜¯å¦ä¸ºå›æ–‡é“¾è¡¨ã€‚å¦‚æœæ˜¯ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚
```
**ç¤ºæ„å›¾**
![](vx_images/119590318230264.png)
###### åŒæŒ‡é’ˆæ³•
```c
bool isPalindrome(struct ListNode *head)
{
    // ç©ºé“¾è¡¨å’Œåªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„é“¾è¡¨éƒ½æ˜¯å›æ–‡é“¾è¡¨
    if (head == NULL || head->next == NULL)
    {
        return true;
    }

    // è®¡ç®—é“¾è¡¨é•¿åº¦
    int len = 0;
    struct ListNode *p = head;
    while (p != NULL)
    {
        len++;
        p = p->next;
    }

    // å°†é“¾è¡¨å‰åŠéƒ¨åˆ†åè½¬
    struct ListNode *prev = NULL;
    struct ListNode *cur = head;
    for (int i = 0; i < len / 2; i++)
    {
        //è¿­ä»£
        struct ListNode *next = cur->next;
        cur->next = prev;
        prev = cur;
        cur = next;
    }

    // å¦‚æœé“¾è¡¨é•¿åº¦æ˜¯å¥‡æ•°ï¼Œè·³è¿‡ä¸­é—´èŠ‚ç‚¹
    if (len % 2 == 1)
    {
        cur = cur->next;
    }

    // æ¯”è¾ƒå‰åŠéƒ¨åˆ†å’ŒååŠéƒ¨åˆ†æ˜¯å¦ç›¸åŒ
    while (prev != NULL && cur != NULL)
    {
        if (prev->val != cur->val)
        {
            return false;
        }
        prev = prev->next;
        cur = cur->next;
    }

    return true;
}

```
###### é€’å½’
```c
// å®šä¹‰ä¸€ä¸ªå…¨å±€å˜é‡frontPointerï¼ŒæŒ‡å‘é“¾è¡¨å¤´éƒ¨
struct ListNode *frontPointer;

// é€’å½’å‡½æ•°ï¼Œç”¨äºæ£€æŸ¥ä»frontPointerå¼€å§‹çš„é“¾è¡¨èŠ‚ç‚¹æ˜¯å¦å›æ–‡
bool recursivelyCheck(struct ListNode *currentNode)
{
    // é€’å½’ç»ˆæ­¢æ¡ä»¶ï¼šå¦‚æœå½“å‰èŠ‚ç‚¹ä¸ä¸ºç©º
    if (currentNode != NULL)
    {
        // é€’å½’è°ƒç”¨ï¼Œå…ˆæ£€æŸ¥åç»­èŠ‚ç‚¹æ˜¯å¦å›æ–‡ï¼Œå¦‚æœä¸æ˜¯åˆ™è¿”å›false
        if (!recursivelyCheck(currentNode->next))
        {
            return false;
        }
        // æ£€æŸ¥å½“å‰èŠ‚ç‚¹å’ŒfrontPointeræ‰€æŒ‡å‘çš„èŠ‚ç‚¹çš„å€¼æ˜¯å¦ç›¸ç­‰ï¼Œå¦‚æœä¸æ˜¯åˆ™è¿”å›false
        if (currentNode->val != frontPointer->val)
        {
            return false;
        }
        frontPointer = frontPointer->next;
    }
    // å¦‚æœéå†åˆ°é“¾è¡¨æœ«å°¾ï¼Œè¯´æ˜é“¾è¡¨æ˜¯å›æ–‡çš„ï¼Œè¿”å›true
    return true;
}

// åˆ¤æ–­é“¾è¡¨æ˜¯å¦å›æ–‡çš„å‡½æ•°
bool isPalindrome(struct ListNode *head)
{
    frontPointer = head;
    return recursivelyCheck(head);
}

```
::: alert-w
æ³¨æ„ï¼š
è‹¥é“¾è¡¨å¯¹ç§°èŠ‚ç‚¹å‡ºç°**å€¼ä¸ç›¸ç­‰**çš„æƒ…å†µï¼Œ`if (currentNode->val != frontPointer->val) {
            return false;
        }`ä¼šè¿”å›`false`
        è€Œå¯¹äº`if (!recursivelyCheck(currentNode->next)) {
            return false;
        }`è€Œè¨€ï¼Œä¼š**è¿›å…¥ifè¯­å¥**ï¼Œä»è€Œè¿›å…¥å¿«é€Ÿå¼¹å‡ºæ ˆé˜¶æ®µ
:::

##### åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨
**é¢˜ç›®è¦æ±‚**
:::alert-info
å°†**ä¸¤ä¸ªå‡åº**é“¾è¡¨åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„ **å‡åº** é“¾è¡¨å¹¶è¿”å›ã€‚æ–°é“¾è¡¨æ˜¯é€šè¿‡æ‹¼æ¥ç»™å®šçš„ä¸¤ä¸ªé“¾è¡¨çš„æ‰€æœ‰èŠ‚ç‚¹ç»„æˆçš„ã€‚ 
:::
**ç¤ºæ„å›¾**
![](vx_images/392020719230265.png)
###### è¿­ä»£æ³•
```c
    struct ListNode *mergeTwoLists(struct ListNode *list1, struct ListNode *list2)
{
    // åˆ¤æ–­æ˜¯å¦ä¸ºç©ºé“¾è¡¨
    if (list1 == NULL)
        return list2;
    if (list2 == NULL)
        return list1;

    // æŒ‡é’ˆåˆ›å»º,curçš„ä½œç”¨æ˜¯ç»™prevé‡æ–°å®šä½
    struct ListNode *prevA = list1;
    struct ListNode *prevB = list2;
    struct ListNode *curA = prevA;
    struct ListNode *curB = prevB;

    while (prevA != NULL && prevB != NULL && (swA || swB))
    {
        if (prevA->val <= prevB->val)
        {
            //ç”¨äºå¿«é€Ÿè·³è¿‡ç¬¦åˆæ¡ä»¶çš„èŠ‚ç‚¹
            while (prevA->next != NULL && prevA->next->val <= prevB->val) 
            {
                prevA = prevA->next;
                if (prevA->next != NULL)
                    curA = prevA->next;
            }

            // æœªè¿›å…¥whileå¾ªç¯æ—¶curè‡ªåŠ¨å‘å‰,åŒæ—¶æ˜¯prev=NULLçš„å…³é”®
            if (curA != prevA->next)
                curA = prevA->next;
 
            //åˆå¹¶èŠ‚ç‚¹å¹¶é‡æ–°å®šä½
            prevA->next = prevB;
            prevA = curA; 
        }
        else if (prevB->val < prevA->val)
        {
            while (prevB->next != NULL && prevB->next->val < prevA->val)
            {
                prevB = prevB->next;
                if (prevB->next != NULL)
                    curB = prevB->next;
            }

            if (curB != prevB->next)
                curB = prevB->next;

            prevB->next = prevA;
            prevB = curB; 
        }
    }

    //æ ¹æ®é¦–èŠ‚ç‚¹çš„å¤§å°åˆ¤æ–­è°çš„æŒ‡é’ˆå…ˆå‘ç”Ÿæ”¹å˜
    if (list1->val <= list2->val)
        return list1;
    else
        return list2;
}
```

###### é€’å½’
```c
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2)
{
    if(list1 == NULL) //è‹¥l1å…ˆè¾¾åˆ°NULLï¼Œè¯´æ˜l1æœ€åä¸€ä¸ªèŠ‚ç‚¹ä»ä¸èƒ½å¤§äºl2ç›®å‰èŠ‚ç‚¹
        return list2;
    else if(list2 == NULL)
        return list1;//åŒç†
    else if(list1->val <list2->val) //å½“l1<l2æ—¶ï¼Œl1ä¼šåˆ°è¾¾ä¸‹ä¸€ä¸ªèŠ‚ç‚¹è¿›è¡Œæ¯”è¾ƒ
    {
        list1->next = mergeTwoLists(list1->next,list2);
        return list1; //åœ¨æ ˆå¼¹å‡ºæ—¶ä¸»åŠ¨æƒåœ¨l1ï¼Œä¸ºäº†ä½¿l2->nextè¿æ¥l1ï¼Œéœ€è¿”å›l1
    }
    else//list2->val <= list1->val
    {
        list2->next = mergeTwoLists(list1,list2->next);
        return list2;//ä¸l1åŒç†
    }
}
```
**é€’å½’æµç¨‹**

```
mergeTwoLists --> mTL | list1 --> l1 | list2 --> l2
l1 = [1,2,5] | l2 = [1,3,4]
=====================================================
l2[1]->next = mTL(1,1->next(3))
    l1[1]->next = mTL(1->next(2),3)
        l1[2]->next = mTL(2->next(5),3)
            l2[3]->next = mTL(5,3->next(4))
                l2[4]->next = mTL(5,4->next(NULL))
-------------------------------------------------
                l1[5]
            l2[4]
        l2[3]
    l1[2]
l1[1]
======================================================             
```
>é€’å½’æµç¨‹å¯ç”¨**ç”»åœˆæ³•**æˆ–åˆ™**Vå‹æ³•**æ¥åš
##### ä¸¤æ•°ç›¸åŠ 
**é¢˜ç›®è¦æ±‚**

:::alert-info
ç»™ä½ ä¸¤ä¸ª **éç©º** çš„é“¾è¡¨ï¼Œè¡¨ç¤ºä¸¤ä¸ªéè´Ÿçš„æ•´æ•°ã€‚å®ƒä»¬æ¯ä½æ•°å­—éƒ½æ˜¯æŒ‰ç…§ **é€†åº** çš„æ–¹å¼å­˜å‚¨çš„ï¼Œå¹¶ä¸”æ¯ä¸ªèŠ‚ç‚¹åªèƒ½å­˜å‚¨ **ä¸€ä½** æ•°å­—ã€‚
è¯·ä½ å°†ä¸¤ä¸ªæ•°ç›¸åŠ ï¼Œå¹¶ä»¥ç›¸åŒå½¢å¼è¿”å›ä¸€ä¸ªè¡¨ç¤ºå’Œçš„é“¾è¡¨ã€‚
ä½ å¯ä»¥å‡è®¾é™¤äº†æ•°å­— 0 ä¹‹å¤–ï¼Œè¿™ä¸¤ä¸ªæ•°éƒ½ä¸ä¼šä»¥ 0 å¼€å¤´ã€‚
:::
**ç¤ºæ„å›¾**
![](vx_images/18381921248691.png)

###### æ¨¡æ‹Ÿæ³•
```c
struct ListNode *addTwoNumbers(struct ListNode *l1, struct ListNode *l2)
{
    // æ£€æŸ¥è¾“å…¥å‚æ•°æ˜¯å¦ä¸ºç©º
    if (l1 == NULL || l2 == NULL)
    {
        return NULL;
    }

    struct ListNode *pa = l1;
    struct ListNode *pb = l2;
    int carry = 0; // è¿›ä½

    while (pa != NULL || pb != NULL)
    {
        int x = (pa != NULL) ? pa->val : 0; // è·å–å½“å‰èŠ‚ç‚¹çš„å€¼ï¼Œè‹¥ä¸ºç©ºåˆ™ä¸º0
        int y = (pb != NULL) ? pb->val : 0;
        int sum = x + y + carry; // è®¡ç®—ä¸¤ä¸ªèŠ‚ç‚¹å’Œè¿›ä½çš„å’Œ
        carry = sum / 10;        // è®¡ç®—è¿›ä½

        if (pa != NULL)
        {
            pa->val = sum % 10; // æ›´æ–°èŠ‚ç‚¹çš„å€¼
            if (pa->next == NULL && ((pb != NULL && pb->next != NULL) || carry > 0))
            { // è‹¥paçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸ºç©ºï¼Œä¸”pbä¸‹ä¸€èŠ‚ç‚¹ä¸ä¸ºç©ºæˆ–è€…æœ‰è¿›ä½ï¼Œåˆ™æ·»åŠ ä¸€ä¸ªèŠ‚ç‚¹
                pa->next = (struct ListNode *)malloc(sizeof(struct ListNode));
                pa->next->val = 0;
                pa->next->next = NULL;
            }
            pa = pa->next;
        }
        if (pb != NULL)
        {
            pb = pb->next;
        }
    }

    return l1;
}
```
#####  å¤åˆ¶å¸¦éšæœºæŒ‡é’ˆçš„é“¾è¡¨
**é¢˜ç›®è¦æ±‚**
:::alert-info
ç»™ä½ ä¸€ä¸ªé•¿åº¦ä¸º **n** çš„é“¾è¡¨ï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«ä¸€ä¸ªé¢å¤–å¢åŠ çš„**éšæœºæŒ‡é’ˆ** `random` ï¼Œè¯¥æŒ‡é’ˆå¯ä»¥æŒ‡å‘é“¾è¡¨ä¸­çš„ä»»ä½•èŠ‚ç‚¹æˆ–ç©ºèŠ‚ç‚¹ã€‚

æ„é€ è¿™ä¸ªé“¾è¡¨çš„ æ·±æ‹·è´ã€‚ æ·±æ‹·è´åº”è¯¥æ­£å¥½ç”± n ä¸ª å…¨æ–° èŠ‚ç‚¹ç»„æˆï¼Œå…¶ä¸­æ¯ä¸ªæ–°èŠ‚ç‚¹çš„å€¼éƒ½è®¾ä¸ºå…¶å¯¹åº”çš„åŸèŠ‚ç‚¹çš„å€¼ã€‚æ–°èŠ‚ç‚¹çš„ `next` æŒ‡é’ˆå’Œ `random` æŒ‡é’ˆä¹Ÿéƒ½åº”æŒ‡å‘å¤åˆ¶é“¾è¡¨ä¸­çš„æ–°èŠ‚ç‚¹ï¼Œå¹¶ä½¿åŸé“¾è¡¨å’Œå¤åˆ¶é“¾è¡¨ä¸­çš„è¿™äº›æŒ‡é’ˆèƒ½å¤Ÿè¡¨ç¤ºç›¸åŒçš„é“¾è¡¨çŠ¶æ€ã€‚å¤åˆ¶é“¾è¡¨ä¸­çš„æŒ‡é’ˆéƒ½**ä¸åº”æŒ‡å‘åŸé“¾è¡¨ä¸­çš„èŠ‚ç‚¹** ã€‚

ä¾‹å¦‚ï¼Œå¦‚æœåŸé“¾è¡¨ä¸­æœ‰ X å’Œ Y ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œå…¶ä¸­` X.random --> Y` ã€‚é‚£ä¹ˆåœ¨å¤åˆ¶é“¾è¡¨ä¸­å¯¹åº”çš„ä¸¤ä¸ªèŠ‚ç‚¹ x å’Œ y ï¼ŒåŒæ ·æœ‰` x.random --> y `ã€‚

è¿”å›å¤åˆ¶é“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚

ç”¨ä¸€ä¸ªç”± n ä¸ªèŠ‚ç‚¹ç»„æˆçš„é“¾è¡¨æ¥è¡¨ç¤ºè¾“å…¥/è¾“å‡ºä¸­çš„é“¾è¡¨ã€‚æ¯ä¸ªèŠ‚ç‚¹ç”¨ä¸€ä¸ª `[val, random_index] `è¡¨ç¤ºï¼š

`val`ï¼šä¸€ä¸ªè¡¨ç¤º Node.val çš„æ•´æ•°ã€‚
`random_index`ï¼šéšæœºæŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹ç´¢å¼•ï¼ˆèŒƒå›´ä» 0 åˆ° n-1ï¼‰ï¼›å¦‚æœä¸æŒ‡å‘ä»»ä½•èŠ‚ç‚¹ï¼Œåˆ™ä¸º `null` ã€‚
ä½ çš„ä»£ç  **åª** æ¥å—åŸé“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` ä½œä¸ºä¼ å…¥å‚æ•°ã€‚

>ç®€å•æ¥è¯´ï¼Œå¤åˆ¶ä¸€ä¸ªä¸€æ‘¸ä¸€æ ·çš„é“¾è¡¨ï¼Œä½†åœ°å€éƒ½ä¸åŒ
:::
**ç¤ºæ„å›¾**
![](vx_images/54001116230267.png)
###### å“ˆå¸Œè¡¨  

<mark>æœ¬ä»£ç ä»¥**CPP**ç¼–å†™</mark>
```cpp
#include <iostream>
#include <unordered_map>

using namespace std;

//é“¾è¡¨å®šä¹‰
class Node
{
public:
    int val;
    Node *random;
    Node *next;

    Node(int _val)
    {
        val = _val;
        random = nullptr;
        next = nullptr;
    }
};

class Solution
{
public:
    // å®šä¹‰å“ˆå¸Œè¡¨
    unordered_map<Node *, Node *> myMap;

    Node *copyRandomList(Node *head)
    {
        if (head == nullptr)
            return nullptr;
        if (!myMap.count(head))
        {
            Node *newhead = new Node(head->val);            // åˆ›å»ºä¸€ä¸ªä¸headä¸€æ ·çš„æ–°èŠ‚ç‚¹;
            myMap[head] = newhead;                          // å°†headæ˜ å°„åˆ°newhead
            newhead->next = copyRandomList(head->next);     // ä½¿ç”¨é€’å½’å¤åˆ¶æ–°èŠ‚ç‚¹
            newhead->random = copyRandomList(head->random); // è°ƒç”¨å“ˆå¸Œè¡¨å¤åˆ¶randomæŒ‡é’ˆ
        }
        return myMap[head]; // è¿”å›çš„æ˜¯ä¸€ä¸ªä¸headå±æ€§ç›¸åŒ(åœ°å€ä¸åŒ)çš„newheadæŒ‡é’ˆ
    }
};
```
:::alert-warning
* `myMap[head] = newhead;`ï¼Œæ­¤è¯­å¥è®©`head`æ˜ å°„åˆ°`newhead`ï¼Œå¦‚**index=2çš„headèŠ‚ç‚¹**æ˜ å°„åˆ°**index=2çš„newheadèŠ‚ç‚¹**ï¼Œå½“ä½¿ç”¨`myMap[]`è°ƒç”¨æ—¶ï¼Œä¼šè¿”å›ç›¸åº”çš„`newhead`æŒ‡é’ˆã€‚å¦‚ï¼šä¼ å…¥`head->random`æ—¶å¯¹åº”çš„æ˜¯**index=2çš„headèŠ‚ç‚¹**ï¼Œè¿”å›äº†**index=2çš„newheadèŠ‚ç‚¹æŒ‡é’ˆ**
* `newhead->next = copyRandomList(head->next);`æ­¤è¯­å¥ç”¨äº**èŠ‚ç‚¹å¤åˆ¶**ï¼Œç›´åˆ°`head==nullptr`å‰ï¼Œ`newhead`çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹å‡å±äº**ç‹¬ç«‹å­˜åœ¨çŠ¶æ€**ã€‚åœ¨**æ ˆå¼¹å‡º**æ—¶ï¼Œé€šè¿‡è°ƒç”¨`HashMap`ï¼Œè¿”å›ä¸ä¹‹å¯¹åº”çš„ç³»èŠ‚ç‚¹
:::
###### å…³äºC++Hashè¡¨çš„æ‹“å±•
:::alert-info
>å“ˆå¸Œè¡¨ï¼ˆ`Hash Table`ï¼‰æ˜¯é€šè¿‡æ•£åˆ—è¡¨ï¼ˆ`Hash Table`ï¼‰å®ç°çš„ã€‚æ•£åˆ—è¡¨æ˜¯ä¸€ç§æ•°æ®ç»“æ„ï¼Œå®ƒèƒ½å¤Ÿä»¥**O(1)æ—¶é—´å¤æ‚åº¦**å¿«é€Ÿ<mark>æŸ¥æ‰¾ã€æ’å…¥å’Œåˆ é™¤</mark>å…ƒç´ 

âšªä½¿ç”¨`<unordered_map>`å¤´æ–‡ä»¶ï¼Œ`std`å‘½åç©ºé—´
âšªå®šä¹‰ï¼š`unordered_map <TypeA , TypeB> name;`
* `TypeA`æ˜¯æŒ‡**é”®(Key)**ï¼Œ`TypeB`æ˜¯æŒ‡**å€¼(value)**ï¼Œ**é”®**å¯¹åº”ä¸€ä¸ª**å€¼**ï¼Œä¸€èˆ¬æ¥è¯´ï¼Œ**ä¸€ä¸ªé”®**åªèƒ½å¯¹åº”**ä¸€ä¸ªå€¼**ï¼Œä½†**ä¸€ä¸ªå€¼**å¯ä»¥å¯¹åº”**å¤šä¸ªé”®**
* `name`æ˜¯å“ˆå¸Œè¡¨çš„åå­—ï¼Œå¯ä»¥åœ¨ç¬¦åˆæ¡ä»¶èŒƒå›´å†…ä»»å–

âšªä½¿ç”¨ï¼š`name[key] = value`
>è¯¦ç»†ä¿¡æ¯è®¿é—®C++[HashTableæœ‰å…³å‡½æ•°](../CPP/CPPç¬”è®°.md)
:::

##### æ—‹è½¬é“¾è¡¨
**é¢˜ç›®è¦æ±‚**
:::alert-info
ç»™ä½ ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` ï¼Œæ—‹è½¬é“¾è¡¨ï¼Œå°†é“¾è¡¨æ¯ä¸ªèŠ‚ç‚¹**å‘å³**ç§»åŠ¨ `k` ä¸ªä½ç½®ã€‚
:::
**ç¤ºæ„å›¾**
![](vx_images/274850621230342.png)
###### ç¯æ¨¡æ‹Ÿ
>è§£é¢˜æ€è·¯ï¼šå°†å•é“¾è¡¨å…ˆæ„æˆç¯ï¼Œæ±‚å‡ºçœŸå®ç§»åŠ¨åå¤´èŠ‚ç‚¹ï¼Œæ–­å¼€

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution
{
public:
    ListNode *rotateRight(ListNode *head, int k)
    {
        // ç‰¹æ®Šæƒ…å†µï¼šå¤´æŒ‡é’ˆä¸ºç©ºæˆ–åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›å¤´æŒ‡é’ˆ
        if (head == nullptr || head->next == nullptr)
        {
            return head;
        }

        int len = 0;
        ListNode *pmove = head;
        
        while (pmove->next != nullptr)
        {
            pmove = pmove->next;
            len++;
        }
        len++; //pmove->nextå¾ªç¯åˆ¤æ–­ä¼šå°‘è®¡ä¸€é•¿åº¦
        pmove->next = head;// å½¢æˆç¯å½¢é“¾è¡¨

        // è®¡ç®—çœŸå®éœ€è¦ç§»åŠ¨çš„ä½ç½®
        int realLen = len - k % len;

        // ç§»åŠ¨åˆ°çœŸå®ä½ç½®çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
        pmove = head;
        for (int i = 0; i < realLen - 1; i++)
        {
            pmove = pmove->next;
        }
        
        ListNode *newHead = pmove->next;// æ–°çš„å¤´æŒ‡é’ˆä¸ºçœŸå®ä½ç½®çš„èŠ‚ç‚¹
        pmove->next = nullptr;// æ–­å¼€ç¯å½¢é“¾è¡¨

        return newHead;
    }
};

```
## åŒé“¾è¡¨
### -------------------
<mark>æœ¬ç« èŠ‚å·²é€šè¿‡**ChatGPT**éªŒè¯</mark>
#### å®šä¹‰é“¾è¡¨èŠ‚ç‚¹ç»“æ„ä½“
```c
// å®šä¹‰é“¾è¡¨èŠ‚ç‚¹ç»“æ„ä½“
typedef struct ListNode
{
    int val;
    struct ListNode *prev, *next;
} MyLinkedList;
```
>åœ¨å®šä¹‰`*prev`å’Œ`*next`æ—¶ï¼Œä¸å¯ä»¥ç›´æ¥ä½¿ç”¨`MyLinkedList`

#### åˆ›å»ºé“¾è¡¨å¤´
```c
// åˆ›å»ºé“¾è¡¨å¤´
MyLinkedList *myLinkedListCreate()
{
    MyLinkedList *head = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    if (head == NULL)
    {
        printf("Error: Memory allocation failed\n");  //å†…å­˜ä¸è¶³
        exit(EXIT_FAILURE);
    }
    head->val = 0;
    head->prev = NULL;
    head->next = NULL;
    return head;
}
```
#### è·å–é“¾è¡¨æŒ‡å®šä½ç½®çš„èŠ‚ç‚¹å€¼
```c
// è·å–é“¾è¡¨æŒ‡å®šä½ç½®çš„èŠ‚ç‚¹å€¼
int myLinkedListGet(MyLinkedList *head, int index)
{
    if (head == NULL || index < 0)
    {
        return -1;
    }

    MyLinkedList *curr = head->next;
    int pos = 0;

    while (curr != NULL)
    {
        if (pos == index)
        {
            return curr->val;
        }
        curr = curr->next;
        pos++;
    }
    return -1;
}
```
>`intç±»å‹`å‡½æ•°è¦è¿”å›ä¸€ä¸ªé”™è¯¯æ—¶å¯ä»¥ä½¿ç”¨`return -1`

#### åœ¨é“¾è¡¨å¤´æ·»åŠ èŠ‚ç‚¹(é¦–ä½èŠ‚ç‚¹)
```c
// åœ¨é“¾è¡¨å¤´æ·»åŠ èŠ‚ç‚¹
void myLinkedListAddAtHead(MyLinkedList *head, int val)
{
    if (head == NULL)
    {
        printf("Error: Invalid input\n");
        return;
    }

    MyLinkedList *new_node = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    if (new_node == NULL)
    {
        printf("Error: Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }

    new_node->val = val;
    new_node->prev = NULL;
    new_node->next = NULL;

    // å¦‚æœé“¾è¡¨ä¸ºç©ºï¼Œåˆ™æ–°èŠ‚ç‚¹æˆä¸ºå¤´ç»“ç‚¹
    if (head->next == NULL)
    {
        head->next = new_node;
        new_node->prev = head;
    }
    else // å¦‚æœé“¾è¡¨éç©ºï¼Œåˆ™æ’å…¥åˆ°å¤´ç»“ç‚¹å
    {
        new_node->next = head->next;
        new_node->next->prev = new_node;
        head->next = new_node;
        new_node->prev = head;
    }
}
```

#### åœ¨é“¾è¡¨å°¾éƒ¨æ·»åŠ èŠ‚ç‚¹
```c
void myLinkedListAddAtTail(MyLinkedList *head, int val)
{
    if (head == NULL)
    {
        printf("Error: Invalid input\n");
        return;
    }

    MyLinkedList *new_node = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    if (new_node == NULL)
    {
        printf("Error: Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }
    new_node->val = val;
    new_node->prev = NULL;
    new_node->next = NULL;

    // å¦‚æœé“¾è¡¨ä¸ºç©ºï¼Œåˆ™æ–°èŠ‚ç‚¹æˆä¸ºé¦–ä½ç»“ç‚¹
    if (head->next == NULL)
    {
        head->next = new_node;
        new_node->prev = head;
    }
    else // å¦‚æœé“¾è¡¨éç©ºï¼Œåˆ™æ’å…¥åˆ°é“¾è¡¨å°¾éƒ¨
    {
        MyLinkedList *curr = head;
        while (curr->next != NULL)
        {
            curr = curr->next;
        }
        curr->next = new_node;
        new_node->prev = curr;
    }
}
```

#### åœ¨é“¾è¡¨æŒ‡å®šä½ç½®æ’å…¥èŠ‚ç‚¹
```c
/* åœ¨é“¾è¡¨æŒ‡å®šä½ç½®æ’å…¥èŠ‚ç‚¹ */
void myLinkedListAddAtIndex(MyLinkedList *head, int index, int val)
{
    // æ£€æŸ¥å¤´èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨
    if (head == NULL)
    {
        printf("Error: Head node is not initialized\n");
        return;
    }

    // æ£€æŸ¥ç´¢å¼•æ˜¯å¦åˆæ³•
    if (index < 0)
    {
        printf("Error: Invalid index\n");
        return;
    }

    // åœ¨é“¾è¡¨å¼€å¤´æ’å…¥èŠ‚ç‚¹
    if (index == 0)
    {
        myLinkedListAddAtHead(head, val);
        return;
    }

    // åˆ›å»ºæ–°èŠ‚ç‚¹
    MyLinkedList *newNode = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    if (newNode == NULL)
    {
        printf("Error: Memory allocation failed\n");
        return;
    }
    newNode->val = val;
    newNode->prev = NULL;
    newNode->next = NULL;

    // éå†é“¾è¡¨ï¼Œæ‰¾åˆ°æ’å…¥ä½ç½®çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
    MyLinkedList *cur = head;
    int pos = 0;
    while (cur->next != NULL)
    {
        if (pos == index - 1)
        {
            break;
        }
        cur = cur->next;
        pos++;
    }

    // æ’å…¥èŠ‚ç‚¹
    if (cur->next != NULL)
    {
        newNode->next = cur->next;
        newNode->next->prev = newNode;
        cur->next = newNode;
        newNode->prev = cur;
    }
    else // å°¾èŠ‚ç‚¹
    {
        cur->next = newNode;
        newNode->prev = cur;
    }
}
```
#### åˆ é™¤é“¾è¡¨æŒ‡å®šä½ç½®çš„èŠ‚ç‚¹
```c
/* åˆ é™¤é“¾è¡¨æŒ‡å®šä½ç½®çš„èŠ‚ç‚¹ */
void myLinkedListDeleteAtIndex(MyLinkedList *head, int index)
{
    // æ£€æŸ¥å¤´èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨
    if (head == NULL)
    {
        printf("Error: Head node is not initialized\n");
        return;
    }

    // æ£€æŸ¥ç´¢å¼•æ˜¯å¦åˆæ³•
    if (index < 0)
    {
        printf("Error: Invalid index\n");
        return;
    }

    // éå†é“¾è¡¨ï¼Œæ‰¾åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
    MyLinkedList *cur = head;
    int pos = 0;
    while (cur->next != NULL)
    {
        if (pos == index - 1)
        {
            break;
        }
        cur = cur->next;
        pos++;
    }

    // åˆ é™¤èŠ‚ç‚¹
    if (cur->next != NULL)
    {
        cur->next = cur->next->next;
        if (cur->next != NULL)
        {
            cur->next->prev = cur;
        }
    }
    else // åˆ é™¤å°¾èŠ‚ç‚¹
    {
        cur->prev->next = NULL;
    }
}
```
:::alert-info
è§£æ**åˆ é™¤èŠ‚ç‚¹**ä¸­çš„
```c
if (cur->next != NULL)
    {
        cur->next = cur->next->next;
        if (cur->next != NULL)
        {
            cur->next->prev = cur;
        }
    }
```
åˆ¤æ–­ä¸¤æ¬¡**ifè¯­å¥**çš„åŸå› :
å½“`cur`ä½äº**å€’æ•°ç¬¬äºŒä¸ªèŠ‚ç‚¹**æ—¶ï¼Œç¬¬ä¸€å±‚**ifè¯­å¥**åˆ¤æ–­ä¸º`true`ï¼Œè€Œç»è¿‡`cur->next=cur->next->next`åï¼Œ`cur->next`å®é™…ä¸Šæ˜¯æŒ‡å‘`null`ï¼Œå› æ­¤ï¼Œæ— é¡»è®¾ç½®**prevæŒ‡é’ˆ**
:::
#### å†…å­˜é‡Šæ”¾-é€’å½’
```c
/*å†…å­˜é‡Šæ”¾-é€’å½’*/
void myListFree(MyLinkedList *node)
{
    if (node->next != NULL)
    {
        myListFree(node->next);
        node->next = NULL;
    }
    node->prev = NULL;
    free(node);
}

void myLinkedListFree(MyLinkedList *head)
{
    MyLinkedList *node = head;
    myListFree(node);
}
```

#### å®Œæ•´å®ç°
```c
#include <stdio.h>
#include <stdlib.h>

// å®šä¹‰é“¾è¡¨èŠ‚ç‚¹ç»“æ„ä½“
typedef struct ListNode
{
    int val;
    struct ListNode *prev, *next;
} MyLinkedList;

// åˆ›å»ºé“¾è¡¨å¤´
MyLinkedList *myLinkedListCreate()
{
    MyLinkedList *head = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    if (head == NULL)
    {
        printf("Error: Memory allocation failed\n"); // å†…å­˜æ»¡
        exit(EXIT_FAILURE);
    }
    head->val = 0;
    head->prev = NULL;
    head->next = NULL;
    return head;
}

// è·å–é“¾è¡¨æŒ‡å®šä½ç½®çš„èŠ‚ç‚¹å€¼
int myLinkedListGet(MyLinkedList *head, int index)
{
    if (head == NULL || index < 0)
    {
        return -1;
    }

    MyLinkedList *curr = head->next;
    int pos = 0;

    while (curr != NULL)
    {
        if (pos == index)
        {
            return curr->val;
        }
        curr = curr->next;
        pos++;
    }
    return -1;
}

// åœ¨é“¾è¡¨å¤´æ·»åŠ èŠ‚ç‚¹
void myLinkedListAddAtHead(MyLinkedList *head, int val)
{
    if (head == NULL)
    {
        printf("Error: Invalid input\n");
        return;
    }

    MyLinkedList *new_node = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    if (new_node == NULL)
    {
        printf("Error: Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }

    new_node->val = val;
    new_node->prev = NULL;
    new_node->next = NULL;

    // å¦‚æœé“¾è¡¨ä¸ºç©ºï¼Œåˆ™æ–°èŠ‚ç‚¹æˆä¸ºå¤´ç»“ç‚¹
    if (head->next == NULL)
    {
        head->next = new_node;
        new_node->prev = head;
    }
    else // å¦‚æœé“¾è¡¨éç©ºï¼Œåˆ™æ’å…¥åˆ°å¤´ç»“ç‚¹å
    {
        new_node->next = head->next;
        new_node->next->prev = new_node;
        head->next = new_node;
        new_node->prev = head;
    }
}

// åœ¨é“¾è¡¨å°¾éƒ¨æ·»åŠ èŠ‚ç‚¹
void myLinkedListAddAtTail(MyLinkedList *head, int val)
{
    if (head == NULL)
    {
        printf("Error: Invalid input\n");
        return;
    }

    MyLinkedList *new_node = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    if (new_node == NULL)
    {
        printf("Error: Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }
    new_node->val = val;
    new_node->prev = NULL;
    new_node->next = NULL;

    // å¦‚æœé“¾è¡¨ä¸ºç©ºï¼Œåˆ™æ–°èŠ‚ç‚¹æˆä¸ºé¦–ä½ç»“ç‚¹
    if (head->next == NULL)
    {
        head->next = new_node;
        new_node->prev = head;
    }
    else // å¦‚æœé“¾è¡¨éç©ºï¼Œåˆ™æ’å…¥åˆ°é“¾è¡¨å°¾éƒ¨
    {
        MyLinkedList *curr = head;
        while (curr->next != NULL)
        {
            curr = curr->next;
        }
        curr->next = new_node;
        new_node->prev = curr;
    }
}

/* åœ¨é“¾è¡¨æŒ‡å®šä½ç½®æ’å…¥èŠ‚ç‚¹ */
void myLinkedListAddAtIndex(MyLinkedList *head, int index, int val)
{
    // æ£€æŸ¥å¤´èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨
    if (head == NULL)
    {
        printf("Error: Head node is not initialized\n");
        return;
    }

    // æ£€æŸ¥ç´¢å¼•æ˜¯å¦åˆæ³•
    if (index < 0)
    {
        printf("Error: Invalid index\n");
        return;
    }

    // åœ¨é“¾è¡¨å¼€å¤´æ’å…¥èŠ‚ç‚¹
    if (index == 0)
    {
        myLinkedListAddAtHead(head, val);
        return;
    }

    // åˆ›å»ºæ–°èŠ‚ç‚¹
    MyLinkedList *newNode = (MyLinkedList *)malloc(sizeof(MyLinkedList));
    if (newNode == NULL)
    {
        printf("Error: Memory allocation failed\n");
        return;
    }
    newNode->val = val;
    newNode->prev = NULL;
    newNode->next = NULL;

    // éå†é“¾è¡¨ï¼Œæ‰¾åˆ°æ’å…¥ä½ç½®çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
    MyLinkedList *cur = head;
    int pos = 0;
    while (cur->next != NULL)
    {
        if (pos == index - 1)
        {
            break;
        }
        cur = cur->next;
        pos++;
    }

    // æ’å…¥èŠ‚ç‚¹
    if (cur->next != NULL)
    {
        newNode->next = cur->next;
        newNode->next->prev = newNode;
        cur->next = newNode;
        newNode->prev = cur;
    }
    else // å°¾èŠ‚ç‚¹
    {
        cur->next = newNode;
        newNode->prev = cur;
    }
}

/* åˆ é™¤é“¾è¡¨æŒ‡å®šä½ç½®çš„èŠ‚ç‚¹ */
void myLinkedListDeleteAtIndex(MyLinkedList *head, int index)
{
    // æ£€æŸ¥å¤´èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨
    if (head == NULL)
    {
        printf("Error: Head node is not initialized\n");
        return;
    }

    // æ£€æŸ¥ç´¢å¼•æ˜¯å¦åˆæ³•
    if (index < 0)
    {
        printf("Error: Invalid index\n");
        return;
    }

    // éå†é“¾è¡¨ï¼Œæ‰¾åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
    MyLinkedList *cur = head;
    int pos = 0;
    while (cur->next != NULL)
    {
        if (pos == index - 1)
        {
            break;
        }
        cur = cur->next;
        pos++;
    }

    // åˆ é™¤èŠ‚ç‚¹
    if (cur->next != NULL)
    {
        cur->next = cur->next->next;
        if (cur->next != NULL) 
        {
            cur->next->prev = cur;
        }
    }
    else // åˆ é™¤å°¾èŠ‚ç‚¹
    {
        cur->prev->next = NULL;
    }
}

/*å†…å­˜é‡Šæ”¾-é€’å½’*/
void myListFree(MyLinkedList *node)
{
    if (node->next != NULL)
    {
        myListFree(node->next);
        node->next = NULL;
    }
    node->prev = NULL;
    free(node);
}

void myLinkedListFree(MyLinkedList *head)
{
    MyLinkedList *node = head;
    myListFree(node);
}

int main()
{
    MyLinkedList *head = myLinkedListCreate();
    myLinkedListAddAtHead(head, 1);
    myLinkedListAddAtTail(head, 10);
    myLinkedListAddAtIndex(head, 0, 2);
    myLinkedListAddAtIndex(head, 1, 3);
    myLinkedListDeleteAtIndex(head, 1);
    // myLinkedListFree(head);

    MyLinkedList *list_move = head;
    while (list_move != NULL)
    {
        printf("%d\n", list_move->val); // 0 2 1 10
        list_move = list_move->next;
    }

    int val = myLinkedListGet(head, 1); // 1
    printf("val-->%d\n", val);

    system("pause");
}


```
#### å°é¢˜
##### æ‰å¹³åŒ–å¤šçº§åŒå‘é“¾è¡¨
**é¢˜ç›®è¦æ±‚**
:::alert-info
ä½ ä¼šå¾—åˆ°ä¸€ä¸ª**åŒé“¾è¡¨**ï¼Œå…¶ä¸­åŒ…å«çš„èŠ‚ç‚¹æœ‰ä¸€ä¸ªä¸‹ä¸€ä¸ªæŒ‡é’ˆã€ä¸€ä¸ªå‰ä¸€ä¸ªæŒ‡é’ˆå’Œä¸€ä¸ª**é¢å¤–çš„** å­æŒ‡é’ˆ ã€‚è¿™ä¸ªå­æŒ‡é’ˆå¯èƒ½æŒ‡å‘ä¸€ä¸ªå•ç‹¬çš„åŒå‘é“¾è¡¨ï¼Œä¹ŸåŒ…å«è¿™äº›ç‰¹æ®Šçš„èŠ‚ç‚¹ã€‚è¿™äº›å­åˆ—è¡¨å¯ä»¥æœ‰ä¸€ä¸ªæˆ–å¤šä¸ªè‡ªå·±çš„å­åˆ—è¡¨ï¼Œä»¥æ­¤ç±»æ¨ï¼Œä»¥ç”Ÿæˆå¦‚ä¸‹é¢çš„ç¤ºä¾‹æ‰€ç¤ºçš„ å¤šå±‚æ•°æ®ç»“æ„ ã€‚

ç»™å®šé“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` ï¼Œå°†é“¾è¡¨ æ‰å¹³åŒ– ï¼Œä»¥ä¾¿æ‰€æœ‰èŠ‚ç‚¹éƒ½å‡ºç°åœ¨å•å±‚åŒé“¾è¡¨ä¸­ã€‚è®© `curr` æ˜¯ä¸€ä¸ªå¸¦æœ‰å­åˆ—è¡¨çš„èŠ‚ç‚¹ã€‚å­åˆ—è¡¨ä¸­çš„èŠ‚ç‚¹åº”è¯¥å‡ºç°åœ¨æ‰å¹³åŒ–åˆ—è¡¨ä¸­çš„ `curr` ä¹‹å å’Œ `curr.next` ä¹‹å‰ ã€‚

è¿”å› æ‰å¹³åˆ—è¡¨çš„ `head` ã€‚åˆ—è¡¨ä¸­çš„èŠ‚ç‚¹å¿…é¡»å°†å…¶ **æ‰€æœ‰** å­æŒ‡é’ˆè®¾ç½®ä¸º `null` ã€‚
:::
**ç¤ºæ„å›¾**
![](vx_images/404714216230266.png)
![](vx_images/4954316248692.png)
###### æ·±åº¦ä¼˜å…ˆæœç´¢
<mark>æ­¤è§£é¢˜æ–¹æ³•ä½¿ç”¨`C++`è§£å†³</mark>
```cpp
#include <iostream>
#include <functional>

using namespace std;    

//èŠ‚ç‚¹å®šä¹‰
class Node {
public:
    int val;
    Node* prev;
    Node* next;
    Node* child;
};


class Solution
{
public:
    Node *flatten(Node *head)
    {
        if (head == nullptr)
            return nullptr;
        function<Node *(Node *)> flattenList = [&](Node *node)
        {
            Node *cur = node;
            Node *last = nullptr;

            while (cur)
            {
                Node *next = cur->next;
                if (cur->child != nullptr) // æ‹¥æœ‰å­é“¾è¡¨æ—¶
                {
                    Node *child_last = flattenList(cur->child); // ä¼ å…¥å­é“¾è¡¨çš„å¤´èŠ‚ç‚¹,å¹¶å¾—åˆ°å­é“¾è¡¨çš„å°¾æŒ‡é’ˆ

                    // è¿æ¥èŠ‚ç‚¹
                    cur->child->prev = cur;
                    cur->next = cur->child;

                    if (next != nullptr) // curåå­˜åœ¨èŠ‚ç‚¹æ—¶
                    {
                        next->prev = child_last;
                        child_last->next = next;
                    }
                    cur->child = nullptr;
                    last = child_last; // åœ¨æœ¬æ¬¡å¾ªç¯ç»“æŸåï¼Œcurä¼šåœ¨laståä¸€ä¸ªèŠ‚ç‚¹
                }
                else
                {
                    last = cur; // è®°å½•é“¾è¡¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹
                }
                cur = next; // curå‰è¿›ä¸€èŠ‚ç‚¹ï¼Œå½“ä¸ºnullptræ—¶ï¼Œé€€å‡ºå¾ªç¯å¹¶è¿”å›å‰ä¸€ä¸ªèŠ‚ç‚¹æŒ‡é’ˆlast
            }
            return last;
        };
        flattenList(head); // è¿è¡ŒflattenListçš„ç¬¬ä¸€æ­¥
        return head;
    }
};
```
:::alert-w
çŸ¥è¯†ç‚¹:
`function<Node *(Node *)> flattenList = [&](Node *node){}ï¼›`ä¸ºä½¿ç”¨ **Lambda è¡¨è¾¾å¼**å®šä¹‰çš„**é€’å½’**å‡½æ•°å¯¹è±¡
â‘ `function<typeA(typeB)>`æ˜¯ä¸€ä¸ª**å‡½æ•°æŒ‡é’ˆç±»å‹**çš„å®šä¹‰ï¼Œå®ƒæ¥å—ä¸€ä¸ª`typeB`ç±»å‹çš„å‚æ•°ï¼Œå¹¶**è¿”å›**ä¸€ä¸ª`typeA`ç±»å‹çš„å‚æ•°ã€‚éœ€è¦ä½¿ç”¨åˆ°`#include <functional>`å’Œ`std`
â‘¡`flattenList`æ˜¯ä¸€ä¸ªå˜é‡åï¼Œç”¨äº**è°ƒç”¨å‡½æ•°**ï¼Œå¯å–å…¶ä»–åå­—
â‘¢`[]`æ˜¯`Lambdaè¡¨è¾¾å¼`çš„**æ•è·åˆ—è¡¨**ï¼Œå…¶ä¸­`&`è¡¨ç¤ºä»¥**å¼•ç”¨æ–¹å¼**æ•è·<mark>æ‰€æœ‰å¤–éƒ¨å˜é‡</mark>ï¼Œä¹Ÿå¯ä»¥ç”¨ `=` è¡¨ç¤ºä»¥**å€¼æ–¹å¼**æ•è·<mark>æ‰€æœ‰å¤–éƒ¨å˜é‡</mark>ï¼Œæˆ–è€…æŒ‡å®šå…·ä½“çš„å¤–éƒ¨å˜é‡å
â‘£`[](Type name)`æ˜¯`Lambdaè¡¨è¾¾å¼`çš„å‚æ•°åˆ—è¡¨ï¼Œè¡¨ç¤ºè¿™ä¸ª`Lambdaè¡¨è¾¾`æ¥å—ä¸€ä¸ª`Type`ç±»å‹çš„å‚æ•°ï¼Œ`name`æ˜¯**å½¢å‚å**
â‘£`{â€¦â€¦}ï¼›`æ˜¯å‡½æ•°ä½“ï¼Œæœ«å°¾éœ€è¦`;`
:::
###### å…³äºC++Lambdaè¡¨è¾¾å¼çš„æ‹“å±•
:::alert-info
å®šä¹‰ï¼šLambdaè¡¨è¾¾å¼æ˜¯C++11å¼•å…¥çš„ä¸€ç§ä¾¿æ·çš„å‡½æ•°å¯¹è±¡å½¢å¼ï¼Œå¯ä»¥åœ¨å‡½æ•°ä¸­å®šä¹‰ä¸€ä¸ªåŒ¿åå‡½æ•°å¹¶ç›´æ¥è°ƒç”¨ï¼Œè€Œæ— éœ€å®šä¹‰å‡½æ•°åã€‚

`[capture_list] (parameters) -> return_type { body }`

âšª`capture_list`ï¼ˆæ•è·åˆ—è¡¨ï¼‰æ˜¯ä¸€ä¸ªå¯é€‰é¡¹ï¼Œç”¨äºæŒ‡å®š`Lambdaå‡½æ•°`åœ¨å®šä¹‰æ—¶å¯ä»¥è®¿é—®å“ªäº›**å¤–éƒ¨å˜é‡**ã€‚æ•è·åˆ—è¡¨å¯ä»¥åŒ…å«ä»¥ä¸‹å†…å®¹ï¼š

â… .ç©ºæ•è·åˆ—è¡¨ `[]`ï¼šä¸æ•è·ä»»ä½•å¤–éƒ¨å˜é‡ã€‚
â…¡.å€¼æ•è·`[=]`ï¼šä»¥**å€¼**çš„æ–¹å¼æ•è·æ‰€æœ‰å¤–éƒ¨å˜é‡ï¼Œå³**å¤åˆ¶**ä¸€ä»½å¤–éƒ¨å˜é‡çš„å‰¯æœ¬åˆ°Lambdaå‡½æ•°ä¸­ã€‚
â…¢.å¼•ç”¨æ•è· `[&]`ï¼šä»¥**å¼•ç”¨**çš„æ–¹å¼æ•è·æ‰€æœ‰å¤–éƒ¨å˜é‡ï¼Œå³è®©`Lambdaå‡½æ•°`ä¸­çš„å˜é‡ä¸å¤–éƒ¨å˜é‡<mark>å…±äº«åŒä¸€åœ°å€</mark>ã€‚
â…£.æ˜¾å¼æ•è· `[var1, var2, ...]`ï¼šæŒ‡å®šè¦æ•è·çš„å¤–éƒ¨å˜é‡çš„åˆ—è¡¨ã€‚å¯ä»¥é€‰æ‹©å€¼æ•è·æˆ–å¼•ç”¨æ•è·ï¼Œä¹Ÿå¯ä»¥æ··åˆä½¿ç”¨ã€‚
â…¤.å˜é‡æ•è·` [=, &var] æˆ– [&, var]`ï¼šæ··åˆä½¿ç”¨å€¼æ•è·å’Œå¼•ç”¨æ•è·ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ=, &varè¡¨ç¤ºä»¥å€¼çš„æ–¹å¼æ•è·**é™¤varä»¥å¤–**çš„æ‰€æœ‰å¤–éƒ¨å˜é‡ï¼Œä»¥<mark>å¼•ç”¨çš„æ–¹å¼æ•è·varå˜é‡</mark>ï¼›&var, =åˆ™ç›¸åï¼Œå…ˆä»¥å¼•ç”¨çš„æ–¹å¼æ•è·varå˜é‡ï¼Œå†ä»¥å€¼çš„æ–¹å¼æ•è·å…¶ä»–æ‰€æœ‰å¤–éƒ¨å˜é‡ã€‚

âšª`parameters`ï¼ˆå‚æ•°åˆ—è¡¨ï¼‰ï¼šç”¨äºæŒ‡å®š`Lambdaè¡¨è¾¾å¼`çš„**å½¢å‚åˆ—è¡¨**ï¼Œä¸æ™®é€šå‡½æ•°çš„å½¢å¼ç›¸åŒã€‚

âšª`return type`ï¼ˆè¿”å›ç±»å‹ï¼‰ï¼šç”¨äºæŒ‡å®š`Lambdaè¡¨è¾¾å¼`çš„**è¿”å›å€¼ç±»å‹**ï¼Œä¸æ™®é€šå‡½æ•°çš„è¿”å›ç±»å‹ç›¸åŒã€‚å¦‚æœçœç•¥ï¼Œç¼–è¯‘å™¨ä¼šæ ¹æ®å‡½æ•°ä½“æ¨æ–­è¿”å›ç±»å‹ã€‚

âšª`{}`ï¼ˆå‡½æ•°ä½“ï¼‰ï¼šç”¨äºæŒ‡å®š`Lambdaè¡¨è¾¾å¼`çš„å‡½æ•°ä½“ï¼Œä¸æ™®é€šå‡½æ•°çš„è¯­æ³•ç›¸åŒã€‚

>`[capture list]`ã€`(parameters)`å’Œ`-> return type`æ˜¯**å¯é€‰çš„**ï¼Œå¯ä»¥æ ¹æ®éœ€è¦çœç•¥ã€‚
:::
## ç¯å½¢é“¾è¡¨

### -------------------

```c
ç¯å½¢é“¾è¡¨ç¤ºæ„å›¾
head---> 1 ---> 2 ---> 3
         â†‘             â†“
         ---------------  
```
#### ç¯å½¢é“¾è¡¨çš„åˆ¤æ–­
:::alert-info
åˆ¤æ–­ç¯å½¢é“¾è¡¨æœ‰ä¸¤ç§æ–¹æ³•
â‘ ç”¨å“ˆå¸Œè¡¨è®°å½•
â‘¡å¿«æ…¢æŒ‡é’ˆï¼ˆæœ¬ç« é‡ç‚¹ï¼‰
:::
>å¿«æ…¢æŒ‡é’ˆï¼šè®¾å®šä¸€ä¸ªå¿«æŒ‡é’ˆ`*fast`å’Œæ…¢æŒ‡é’ˆ`slow`ï¼Œè‹¥é“¾è¡¨ä¸º**ç¯å½¢é“¾è¡¨**ï¼Œåˆ™`fastå¿…å®šä¼šç­‰äºslow`ï¼ˆfastç»•æ•°åœˆåè¿½ä¸Šslowï¼‰ï¼›è‹¥ä¸ºå•é“¾è¡¨ï¼Œåˆ™`fast==NULL`æˆ–åˆ™`fast->next==NULL`


```c
bool listCycle(struct Node *head)
{
    /*åˆ¤æ–­é“¾è¡¨æ˜¯å¦ä¸ºç©ºé“¾è¡¨*/
    if (head == NULL || head->next == NULL)
        return false;

    /*æ–°å»ºå¿«ã€æ…¢æŒ‡é’ˆ*/
    struct Node *fast = head;
    struct Node *slow = head;

    /*ç¯å½¢é“¾è¡¨åˆ¤æ–­*/
    while (fast != NULL)
    {
        if (fast->next == NULL)
            return false;

        fast = fast->next->next;
        slow = slow->next;

        if (fast == slow)
            return true;
    }

    return false;
}
```
#### ç¯å½¢é“¾è¡¨å…¥ç¯ç‚¹æŸ¥æ‰¾


>è§£æ





![](vx_images/8790919236452.jpeg =1184x)
:::alert-info
è®¾`HEAD`åˆ°`å…¥ç¯ç‚¹`çš„è·ç¦»ä¸º**a**ï¼ˆä¸åŒ…æ‹¬`HEAD`å’Œ`å…¥ç¯ç‚¹`ï¼‰ï¼Œ`å…¥ç¯ç‚¹`åˆ°`ç›¸é‡ç‚¹`çš„è·ç¦»ä¸º**b**ï¼ˆåŒ…æ‹¬`ç›¸é‡ç‚¹`ä½†ä¸åŒ…æ‹¬`å…¥ç¯ç‚¹`ï¼‰ï¼Œ`ç›¸é‡ç‚¹`åˆ°`å…¥ç¯ç‚¹`çš„è·ç¦»ä¸º**c**ï¼ˆåŒ…æ‹¬`å…¥ç¯ç‚¹`ä½†ä¸åŒ…æ‹¬`ç›¸é‡ç‚¹`)
:::
>`fast`èµ°è¿‡çš„è·ç¦»:<mark>**a+n(b+c)+b**</mark>
>`slow`èµ°è¿‡çš„è·ç¦»:<mark>**a+b**</mark>
å› ä¸º`fast`é€Ÿç‡æ˜¯`slow`çš„**ä¸¤å€**

```
å­˜åœ¨ä»¥ä¸‹å…¬å¼:
    a+n(b+c)+b=2(a+b)
åŒ–ç®€:
    a=c+(n-1)(b+c)
```
:::alert-info
å³`HEAD`åˆ°`å…¥ç¯ç‚¹`çš„è·ç¦»ç­‰äº**n-1åœˆ**åŠ ä¸Š`ç›¸é‡ç‚¹`åˆ°`å…¥ç¯ç‚¹`ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨**åŒæŒ‡é’ˆæ³•**
:::
>åŒæŒ‡é’ˆæ³•ï¼šå»ºç«‹ä¸€ä¸ªæ–°çš„æŒ‡é’ˆ`*ptr`æŒ‡å‘`HEAD`ï¼Œ`ptr`ä¸`slow`ä»¥**åŒä¸€é€Ÿç‡**ç»§ç»­å‘å‰ï¼Œå®ƒä»¬<mark>ä¸€å®šä¼šåœ¨`å…¥ç¯ç‚¹`ç›¸é‡</mark>

```c
struct Node *detectCycle(struct Node *head)
{
    if (head == NULL || head->next == NULL)
        return false;

    /*æ–°å»ºå¿«ã€æ…¢æŒ‡é’ˆ*/
    struct Node *fast = head;
    struct Node *slow = head;

    /*ç¯å½¢é“¾è¡¨åˆ¤æ–­*/
    while (fast != NULL)
    {
        if (fast->next == NULL)
            return NULL;

        fast = fast->next->next;
        slow = slow->next;

        if (fast == slow)
        {
            /*åŒæŒ‡é’ˆåˆ¤æ–­*/
            struct Node *ptr = head;
            while (ptr != slow)
            {
                ptr = ptr->next;
                slow = slow->next;
            }
            return ptr;
        }
    }
    return NULL;
}
```


----
## ç›¸äº¤é“¾è¡¨
### -----------------------
#### ç›¸äº¤é“¾è¡¨çš„äº¤ç‚¹æŸ¥æ‰¾
:::alert-light
æ¦‚å¿µ:ä¸¤ä¸ªé“¾è¡¨åœ¨æŸä¸€ç‚¹å¤„**å¼€å§‹æŒ‡å‘åŒä¸€å†…å­˜ä½ç½®**
`![](vx_images/532412521230159.png)``


:::
:::alert-w
æ³¨æ„ï¼š
â‘ **é¦–ä½èŠ‚ç‚¹**åœ¨åŒä¸€å†…å­˜ä½ç½®ä¹Ÿç§°ä¹‹ä¸ºç›¸äº¤
â‘¡**ç›¸äº¤ç‚¹**åç»­èŠ‚ç‚¹å‡å¤„äºåŒä¸€å†…å­˜ä½ç½®
:::

>æ–¹æ³•ä¸€ï¼šæœ«ç«¯åé€€æ³•

```c
struct Node *getIntersectionNode(struct Node *headA, struct Node *headB)
{
    if(headA == NULL && headB == NULL)
        return NULL:
        
	struct Node *last_a;
	struct Node *last_b;
	struct Node *list_move;
	struct Node *record = NULL;
	int a = 0, b = 0;

	/*ä»¤last_aä¸last_bæŒ‡å‘é“¾è¡¨æœ«ç«¯ä¸”è®¡ç®—é•¿åº¦*/
	list_move = headA;
	while (list_move->next != NULL)
	{
		list_move = list_move->next;
		a++;
	}
	last_a = list_move;

	list_move = headB;
	while (list_move->next != NULL)
	{
		list_move = list_move->next;
		b++;
	}
	last_b = list_move;

	/*ä»æœ«ç«¯å‘å‰é€ä¸€æ¯”è¾ƒ*/
	while (last_a == last_b && (last_a != headA || last_b != headB))
	{
		list_move = headA;
		for (int i = 0; i < a; i++)
			list_move = list_move->next;
		last_a = list_move;
		a--;

		list_move = headB;
		for (int i = 0; i < b; i++)
			list_move = list_move->next;
		last_b = list_move;
		b--;

		if (last_a == last_b)
			record = last_a;
	}

	if (record != NULL)
		return record;
	else if (a == 0 && b == 0 && last_a == last_b) //å½“Aã€Bé“¾è¡¨å‡åªæœ‰ä¸€ä¸ªå€¼ä¸”ç›¸ç­‰æ—¶
		return headA;
	else
		return NULL;
}
```


:::alert-info
è‹¥å­˜åœ¨ç»“äº¤ç‚¹åˆ™è¿”å›ç»“äº¤ç‚¹æŒ‡é’ˆï¼Œè‹¥æ— åˆ™è¿”å›`NULL`
:::
    
>æ–¹æ³•äºŒï¼šå‰ç¼€å’Œæ³•
:::alert-dark
è®¾ä¸¤é“¾è¡¨é•¿åº¦åˆ†åˆ«ä¸ºmã€n
å½“`m=n`æ—¶ï¼Œè‹¥ç›¸äº¤ï¼Œå®ƒä»¬ä¼š<mark>åŒæ—¶æŒ‡å‘åŒä¸€å†…å­˜ä½ç½®</mark>
å½“`m!=n`æ—¶ï¼Œå› ä¸º**m+n=n+m**ï¼Œå› æ­¤`listA`éå†Aã€Bé“¾è¡¨çš„é•¿åº¦ä¸`listB`éå†Bã€Aé“¾è¡¨çš„é•¿åº¦ç›¸ç­‰
```
è‹¥æœ‰äº¤ç‚¹ï¼Œåˆ™ä¼šåœ¨ç¬¬äºŒæ¬¡éå†é“¾è¡¨æ—¶ç›¸äº¤
è‹¥æ— äº¤ç‚¹ï¼Œåˆ™ä¼šåŒæ—¶æŒ‡å‘NULL
```
:::

```c
struct Node *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    if(headA==NULL||headB==NULL)
        return NULL;

	/*åŒæŒ‡é’ˆ*/
    struct Node* listA=headA;
    struct Node* listB=headB; 

	/*å’Œç›¸ç­‰*/
    while(listA!=listB){
        listA=(listA==NULL)?headB:listA->next;
        listB=(listB==NULL)?headA:listB->next;
    }
    return listA;
}
```

:::alert-w
æ³¨æ„ï¼šå½“åˆ¤æ–­å‡ºå®ƒä»¬æŒ‡å‘åŒä¸€å†…å­˜ä½ç½®æ—¶ï¼Œ**æ— éœ€å†å¾€åé¢åˆ¤æ–­**ï¼ŒåŒä¸€å†…å­˜ä½ç½®æ‹¥æœ‰<mark>å•å‘æŒ‡å‘æ€§</mark>
:::
>`headA`ä¸`headB`å‡ä¸ºå­˜å‚¨æ­£å¸¸æ•°å€¼å¤´ç»“ç‚¹ï¼Œæ­¤é¢˜ä¸éœ€è¦åˆ¤æ–­`headA->next==NULL || headB->next==NULL`


